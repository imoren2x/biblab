Python para todos
-----------------

 1. Introducción
 2. Tipos básicos/Colecciones
 3. Control de flujo/Funciones			11. Interactuar con webs
 4. Programación orientada a Objetos	12. Serialización de objetos
 5. Excepciones							13. Bases de Datos
 6. Módulos y paquetes					14. Documentación
 7. Entrada/Salida de ficheros			15. Testing
 8. Expresiones regulares				16. Distribuir aplicaciones Python
 9. Sockets								----------------------------------
10. Threads								17. Ofuscación de código

Nivel básico: Hasta el 6
Nivel intermedio: Hasta el 10
Nivel avanzado: todo
Faltan las librerías: Ver referencias
-----------------------------------------------------------------------------------
Referencias:

-----------------------------------------------------------------------------------

Capítulo 1. Introducción
------------------------
1.1 Instalación y versiones
1.2 Mi primer programa en Python

Lenguaje de programación creado por Guido van Rossum hacia 1995.
Es un lenguaje similar a Perl, pero con una sintaxis muy limpia y que favorece un código legible.
Se trata de
	· un lenguaje interpretado o de script,
	· con tipado dinámico,
	· fuertemente tipado,
	· multiplataforma y
	· orientado a objetos.
En Python, el código fuente se traduce a un pseudocódigo máquina intermedio llamado bytecode la primera vez que se ejecuta, generando archivos .pyc o .pyo (bytecode optimizado), que son los que se ejecutarán en sucesivas ocasiones.

1.1 Instalación y versiones
Implementaciones de Python:
	· CPython, en C (el estándar)
	· Jython, en Java
	· IronPython, en C#
	· PyPy, en Python

1.2 Mi primer programa en Python: "hola, mundo"
Dos opciones:
	· Desde el prompt:
		$ python
		>>> print "hola, mundo"

	· Crear el script y luego ejecutarlo:
		$ python hola.py
		Windows:
			hola.py
				print "hola, mundo"
				raw_input()

		Linux:
			$ chmod +x hola.py
			$ ./hola.py
			Hay que usar el shebang, hashbang o sharpbang
			hola.py
				#!/usr/bin/python #o bien #!/usr/bin/env python
				print "Hola Mundo"
				raw_input()

Capítulo 2. Tipos de datos y operadores
---------------------------------------
2.1 Tipos de datos básicos:
	Números		Listas []
	Strings		Tuplas ()
	Booleanos	Diccionarios {:}
2.2 Operadores
2.3 Colecciones
	Listas	Tuplas	Diccionarios

Para conocer el tipo
	>> type(<variable>)
y para convertir un tipo
	>> str(<variable>)
	>> int(<variable>)

2.1.1 Números
	Entero:
		Normal:		>>> x = 3		( type(x) = int )
		Long:		>>> x = 3L		( type(x) = long )
		Octal:		>>> x = 023		( x = 19 en base 10)
		Hex:		>>> x = 0x17	( x = 23 en base 10)
	Coma flotante:	>>> x = 15.57	( type(x) = float )
	Complejos:		>>> x = 3 + 2j	( type(x) = complex )

2.1.2 Strings (cadenas de caracteres)
Puede expresarse de varias formas:
	Comillas simples: 	'hola'
	Comillas dobles:	"hola"
	Unicode:			u"äíè"
	Raw:				r"abc"
Hay caracteres de escape como '\n' o '\t'.
	Comillas triples:
		"""primera línea
			y esto para la segunda línea"""
Operadores:
	+	concatenación
	*	repetición

2.1.3 Valores booleanos: True, False

2.2 Operadores aritméticos, de bits y relacionales
Se aplican a los números.
Para otras operaciones, úsese el método math.

Operadores aritméticos
	+	suma
	-	resta
	*	multiplicación
	/	división
	//	división entera
	%	módulo
	**	exponenciación

Operadores de bits
	&		and
	|		or
	^		xor
	~ 		not
	<< >>	desplazamiento (inserta ceros)

Operadores booleanos
	and		r = True and False
	or		r = True or False
	not		r = not True

Operadores relacionales
Devuelven un tipo booleano.
	==		5 == 3 es False
	!=		5 != 3 es True
	<		5 < 3 es False
	>		5 > 3 es True
	<=		5 <= 3 es True
	>=		5 >= 3 es False

2.3 Colecciones:
Listas
	l = [22, True, "una lista", [1, 2]]
		  0    1        2          3
		 -4   -3       -2         -1

	Slicing:
		(inicio, fin)
		(inicio:fin:salto)
		(inicio:)
		l(0:1) = [22]
		l(0:2) = [22, True]

Tuplas
	t =  1, 2, 3
	t = (1, 2, 3)

	Las tuplas son inmutables, sus valores no se pueden modificar una vez creadas y tienen tamaño fijo.
	También son más ligeras.

Diccionarios (Registros)
	Registros clave/valor:
		d = {"Love actually": "Richard Curtis", "Kill Bill": "Tarantino", "Amèlie": "Jean-Pierre Jenuet"}
	Acceso:
		d("Love actually") # devuelve "Richard Curtis"

Capítulo 3. Control de flujo y funciones
----------------------------------------
Sentencias condicionales
Bucles
Funciones

3.1 Control de flujo
3.1.1 Sentencias condicionales if
	fav = "mundogeek.net"
	# si (if) fav es igual a "mundogeek.net"
	if fav == "mundogeek.net":
		print "Tienes buen gusto!"
		print "Gracias"
	else:
		print "Vaya, que lástima"

	if numero < 0:
		print "Negativo"
	elif numero > 0:
		print "Positivo"
	else:
		print "Cero"

3.1.2 Sentencia condicional A if B else C
	var = "par" if (num % 2 == 0) else "impar"

3.1.3 Bucle While
	edad = 0
	while edad < 18:
	  edad = edad + 1
	  print "Felicidades, tienes " + str(edad)

3.1.4 Bucle for ... in

	secuencia = ["uno", "dos", "tres"]
	for elemento in secuencia:
		print elemento

3.2 Funciones
	Definición de la función:
		def mi_funcion(param1, param2 = 1):
			"""Esta funcion imprime los dos valores pasados
				como parametros"""
			print param1
			print param2

	Formas de llamar a la función:
		mi_funcion("hola")
		mi_funcion("hola", 2)
		mi_funcion(param2 = 2, param1 = "hola")

	Función con número variable de parámetros, se usa el asterisco.
		def varios(param1, param2, *otros):
			for val in otros:
			print val
		Los parámetros se procesan como una tupla.

	Si se emplea **, los parámetros se entienden como un diccionario:
		def varios(param1, param2, **otros):
			for i in otros.items():
				print i

		varios(1, 2, tercero = 3)

	Paso por valor o por referencia:
		En Python, los parámetros se pasan por valor de la referencia, que equivale a referencia.
		En el caso de los objetos inmutables (tuplas o enteros), no se pueden modificar.
		En resumen,
			Inmutables (enteros, tuplas) -> paso por valor
			Mutables (listas)			 -> paso por referencia (con sus propios métodos)

	Retorno de parámetros
		Se utiliza la palabra reservada return.
		En Python, se pueden devolver varios parámetros.

		def f(x, y):
			return x * 2, y * 2

		Llamada: a, b = f(1, 2)

		En realidad, devuelve una tupla como retorno.

Capítulo 4. Clases y objetos
----------------------------
4.1 Clases y objetos
4.2 Herencia
	4.2.1 Herencia múltiple
	4.2.2 Polimorfismo
	4.2.3 Encapsulación
	4.2.4 Clases Python 3.0
	4.2.5 Métodos especiales
4.3 Revisitando Objetos
	4.3.1 Diccionarios
	4.3.2 Cadenas
	4.3.3 Listas

4.1 Clases y objetos
	Clase:
		Entidad que almacena un estado (atributos o propiedades) y unas acciones (métodos).
	Objeto:
		Realización desa clase.
	Palabra reservada:
		class <clase>:

	Por ejemplo:
		class Coche:
			"""Abstraccion de los objetos coche."""
			def __init__(self, gasolina):
				"""Método constructor."""
				#Atributos usando la palabra self.
				self.gasolina = gasolina
				print "Tenemos", gasolina, "litros"
				def arrancar(self):
					if self.gasolina > 0:
						print "Arranca"
					else:
						print "No arranca"

			def conducir(self):
				if self.gasolina > 0:
					self.gasolina -= 1
					print "Quedan", self.gasolina, "litros"
				else:
					print "No se mueve"


	Instanciación:
		mi_coche = Coche(3)

4.2 Herencia:
	La herencia se indica desde la clase hija usando paréntesis con la clase padre.
	Por ejemplo:
		class Instrumento:
			def __init__(self, precio):
				self.precio = precio

			def tocar(self):
				print "Estamos tocando musica"

			def romper(self):
				print "Eso lo pagas tu"
				print "Son", self.precio, "$$$"

		class Bateria(Instrumento):
			pass

		class Guitarra(Instrumento):
			pass

	Sobreescribir métodos del padre:
		Si desde una clase hija hay que sobreescribir métodos del padre, se llama al mismo método.
		Se utiliza comúnmente en los constructores de las clases heredadas.
		Por ejemplo:
			class Guitarra(Instrumento):
				def __init__(self, precio, cuerdas)
					self.cuerdas = cuerdas
					Instrumento.__init__(self, precio)

4.2.1 Herencia múltiple
		En Python se permite la herencia múltiple:
			class Cocodrilo(Terrestre, Acuatico):
				pass
		En caso de colisión entre métodos, tiene más prioridad la primera clase (Terrestre).

4.2.2 Polimorfismo
		En Python el polimorfismo permite que con una clase hija se acceda a los métodos de la clase padre.
		Python no hay restricciones a los tipos que se pueden pasar a una función.
		El polimorfismo no es especialmente importante.
		NO confundir el polimorfismo con la sobrecarga de métodos, donde el mismo método existe con diferentes tipos o número de argumentos.
		La sobrecarga de métodos no existe en Python, se puede simular con valores por defecto para los parámetros o a la sintaxis *params o **params o bien usando decoradores (mecanismo que veremos más adelante).

4.2.3 Encapsulación
		En Python, no hay modificadores de acceso public/private, sino que se utiliza un formato para nombres que lo hacen público o privado.
		El nombre determina si es privado:
			· si el nombre comienza con dos guiones bajos (y no termina también con dos guiones bajos) se trata de una variable o función privada (name mangling),
			· en caso contrario es pública.
		class Ejemplo:
			def publico(self):
				print "Publico"

			def __privado(self):
				print "Privado"

		ej = Ejemplo()
		ej.publico()
		ej.__privado()

		Se recomienda utilizar getters y setters:
			class Fecha():
				def __init__(self):
					self.__dia = 1
				def getDia(self):
					return self.__dia
				def setDia(self, dia):
					if dia > 0 and dia < 31:
						self.__dia = dia
					else:
						print "Error"

			mi_fecha = Fecha()
			mi_fecha.setDia(33)

4.2.4 Clases Python 3.0

4.2.5 Métodos especiales
	Existen seis métodos especiales:
	1. __init__(self, args)
		Inicialización.
	2. __new__(cls, args)
		Python 3.0, constructor que se ejecuta antes de __init__.
	3. __del__(self)
		Destructor
	4. __str__(self)
		Crea una cadena de texto para representar el objeto.
		Se muestra de dos formas:
			· print <objeto>
			· str(<objeto>)
	5. __cmp__(self, otro)
		Comparación entre objetos, por si es mayor, igual o menor.
		Debe devolver:
			· Cero si son iguales.
			· Negativo si es menor que otro.
			· Positivo si es mayor que otro.
		NOTA:
			Si se emplean los operadores == o !=, se compara el mismo id.
	6. __len__(self)
		Devuelve la longitud del objeto.
		Se aplica con len(<objeto>).

Existen más métodos especiales.

4.3 Revisitando Objetos
Puesto que las listas, las cadenas o los diccionarios son objetos, es importante conocer que existen métodos de acceso para ellos.
4.3.1 Diccionarios
	<Type> D.get(k[, d]) devuelve valor de clave k con valor por defecto si no existe.
	d[k] también devuelve valor, pero lanza una excepción si no existe.

	bool D.has_key(k) comprueba si el diccionario tiene la clave k.
	Equivale a k in D.

	<List> D.items() devuelve una lista de tuplas con pares clave-valor.

	<List> D.keys() devuelve una lista de claves del diccionario.

	<List> D.values() devuelve una lista de los valores del diccionario.

	<Type> D.pop(k[, d]) Borra la clave k del diccionario y devuelve su valor. Si no se encuentra dicha clave se devuelve d si se especificó el parámetro o bien se lanza una excepción.

4.3.2 Cadenas / Strings
	S.count(sub[, start[, end]]) devuelve el número de veces que se encuentra sub en la cadena. start y end definen subcadenas.

	int S.find(sub[, start[, end]]) devuelve la posición en la que se encontró por primera vez sub ó -1 si no la encontró.

	S.join(sequence) concatena cadenas.

	S.partition(sep) Busca el separador sep en la cadena y devuelve una tupla con la subcadena hasta dicho separador, el separador en si, y la subcadena del separador hasta el final de la cadena.
	Si no se encuentra el separador, la tupla contendrá la cadena en si y dos cadenas vacías.

	S.replace(old, new[, count]) reemplaza la ocurrencia de old con new, como mucho count veces.

	S.split([sep [,maxsplit]]) devuelve una lista con las subcadenas al dividirlas por sep.

4.3.3 Listas
	L.append(<object>) añade un objeto al final de la lista.

	L.count(value) Devuelve el número de veces que se encontró value en la lista.

	L.extend(iterable) añade los elementos del iterable a la lista.

	L.index(value[, start[, stop]]) devuelve la posición en la que se encontró la primera ocurrencia de value. Si se especifican, start y stop definen las posiciones de inicio y fin de una sublista en la que buscar.

	L.insert(index, object) inserta el objeto object en la posición index.

	L.pop([index]) devuelve el valor en la posición index y lo elimina de la lista. Si no se especifica la posición, se utiliza el último elemento de la lista.

	L.remove(value) eliminar la primera ocurrencia de value en la lista.

	L.reverse() invierte la lista. Esta función trabaja sobre la propia lista desde la que se invoca el método, no sobre una copia.

	L.sort(cmp=None, key=None, reverse=False) Ordena la lista.
		· Si se especifica cmp, este debe ser una función que tome como parámetro dos valores x e y de la lista y devuelva -1 si x es menor que y, 0 si son iguales y 1 si x es mayor que y.
		· El parámetro reverse es un booleano que indica si se debe ordenar la lista de forma inversa, lo que sería equivalente a llamar primero a L.sort() y después a L.reverse().
		· Por último, si se especifica, el parámetro key debe ser una función que tome un elemento de la lista y devuelva una clave a utilizar a la hora de comparar, en lugar del elemento en si.

Capítulo 5. Excepciones
-----------------------
Las excepciones son errores detectados por Python durante la ejecución del programa.
	Ejemplo de excepción no tratada:
		def division(a, b):
			return a / b

		def fExcepNoTrat():
			division(1, 0)

		calcular()

		Genera el error siguiente:
			$ python ejemplo.py
			Traceback (most recent call last):
				File "ejemplo.py", line 7, in
				calcular()
				File "ejemplo.py", line 5, in calcular
				division(1, 0)
				File "ejemplo.py", line 2, in division
				a / b
			ZeroDivisionError: integer division or modulo by zero

		traceback: lista con las llamadas que provocaron la excepción.
		ZeroDivisionError: tipo de excepción.

	Python utiliza la construcción try-except para capturar y tratar excepciones.
	El bloque try define el fragmento de código en el que podría producirse excepción.
	El bloque except procesa el tratamiento de la excepción en caso de producirse.

	Ejemplo de excepción tratada:
		try:
			f = file("archivo.txt")
		except IOError as (errno, strerror):
			print "I/O error({0}): {1}".format(errno, strerror)
		except:
			print "El archivo no existe"
			raise # re-raise the exception (allowing a caller to handle the exception as well)

	Si no existe el archivo pasado como parámetro, se lanza una excepción de tipo IOError, que es capturada.

	Un bloque puede tener varios bloques except:
		try:
			num = int("3a")
			print no_existe
		except NameError:
			print "La variable no existe"
		except ValueError:
			print "El valor no es un numero"

	O usar una tupla para indicar qué tipos de excepciones captura:
		except (RuntimeError, TypeError, NameError):
			pass

	También existe la opción else
	Ejemplo:
		try:
			num = 33
		except:
			print "Hubo un error!"
		else:
			print "Todo esta bien"

	Y también la opción finally, que se ejecuta o no una excepción. Sirve, p.ej., para tareas de limpieza, p.ej., cerrando un fichero que queda abierto o cerrando conexiones de red.
	También se ejecuta en caso de uso de break, continue o return.
	Ejemplo:
		try:
			z = x / y
		except ZeroDivisionError:
			print "Division por cero"
		finally:
			print "Limpiando"

	Crear tus propias excepciones: clase Exception + herencia
	Ejemplo:
		class MiError(Exception):
			def __init__(self, valor):
				self.valor = valor

			def __str__(self):
				return "Error " + str(self.valor)

	Llamada:
		try:
			if resultado > 20:
				raise MiError(33)
		except MiError as e: #also, you can write MiError, e
			print e

	Para ver las 46 excepciones por defecto, consúltese el otro documento.

Capítulo 6. Módulos y paquetes
------------------------------
6.1 Módulos
Los módulos y paquetes permiten almacenar funcionalidades de Python.
	Ejemplo: modulo.py
		def mi_funcion():
			print "una funcion"

		class MiClase:
			def __init__(self):
				print "una clase"

		print "un modulo"

	Llamada:
		import modulo.py
		...
		modulo.mi_funcion()

	Resultado:
		una funcion
		un modulo

	Debe emplearse el nombre de módulo para evitar sobreescrituras entre espacios de nombres de cada módulo.

	El módulo debe estar en el mismo directorio.
	El import ejecuta el módulo, con lo que mostraría el texto "una clase".

	Tres módulos importantes:
		import os, sys, time
		· os 	Funciones del sistema operativo
		· sys 	Funciones del propio intérprete de Python
		· time	Funciones para fechas y horas

	Importación con From-Import (importación al espacio de nombres actual)
		Ejemplo:
			from time import asctime
			...
			print asctime()

		Ejemplo 2:
			from time import * # cuidado con colisiones
			...
			print asctime()

	El Path de Python: PYTHONPATH
		>>> import sys
		>>> sys.path

	En Python los módulos son objetos de tipo module, tienen atributos como __name__, que se usa para ejecutar código sólo si es el main, no si se importa:
	Ejemplo:
		print "Se muestra siempre"
		if __name__ == "__main__":
			print "Se muestra si no es importacion"

		Documentación de módulos:
			__doc__ primera línea del cuerpo del módulo.

6.2 Paquetes
	Los paquetes son entidades mayores que los módulos.
		Módulo 	-> archivo
		Paquete -> directorio

	El archivo __init__ en el directorio hace que Python lo interprete como tal.

	Para llamar una función del módulo:
		import paq.subpaq.modulo

		paq.subpaq.modulo.func()

	PyPI (Python Package Index)
		http://pypi.python.org/


Capítulo 7. Entrada y salida de ficheros
--------------------------------
7.1 Entrada estándar
7.2 Parámetros de línea de comandos
7.3 Salida estándar
7.4 Archivos
	7.4.1 Lectura de archivos
	7.4.2 Escritura de archivos
	7.4.3 Mover el puntero de lectura/escritura
-------------------------------------------------

7.1 Entrada estándar
	nombre = raw_input("Como te llamas? ")
	print "Encantado, " + nombre

7.2 Parámetros de línea de comandos (sys.argv[])
	Parámetros a la hora de llamar al programa en la línea de comandos:
		$ python editor.py hola.txt
	Ejemplos:
		import sys

		if(len(sys.argv) > 1):
			print "Abriendo " + sys.argv[1]
		else:
			print "Debes indicar el nombre del archivo"

	try:
		edad = raw_input("Cuantos anyos tienes? ")
		dias = int(edad) * 365
		# edad = int(raw_int("Cuantos anyos tienes? "))
		print "Has vivido " + str(dias) + " dias"
	except ValueError:
		print "Eso no es un numero"

	Módulo optparse: facilita el trabajo con los argumentos de la línea de comandos.

7.3 Salida estándar
	La forma más común es la función print.
	El uso de la coma hace que se imprima como una tupla o con nueva línea.
		Ejemplo:
			>>> for i in range(3):
			>>> ... print i,
		Resultado:
			0 1 2

		Ejemplo:
			>>> for i in range(3):
			>>> ... print i
		Resultado:
			0
			1
			2

	También es importante usar coma o + con strings:
		Ejemplo:
			print "hola", "mundo"	# en forma de tupla
			print "hola" + "mundo"	# concatenación
		Resultado:
			hola mundo
			holamundo

	Formateo del string:
		print "Hola %s" % "mundo"
		print "%s %s" % ("Hola", "mundo")

	Especificador		Formato
		%s				 Cadena
		%d				 Entero
		%o				 Octal
		%x				 Hexadecimal
		%f				 Real
	Hay también modificadores para mostrar el número de decimales o el número de dígitos.

7.4 Archivos
	Los ficheros son objetos de tipo file.
	Abrir y cerrar ficheros:
		fMiFileDescr = file.open(sFileNameWithPath, sMode)
			sFileNameWithPath
			sMode	"r" "w" "a" "b" "+" "U"
				"r" "w" "a" Lectura/escritura/append
				"+" Permite lectura y escritura simultánea
				"U"	Universal newline
		fMiFileDescr = file.close()

	Funciones de lectura: read, readline y realines
		fMiFileDescr.read(ibuffer):
			completo = f.read() # Lee hasta el final#
			parte = f2.read(512) # Lee 511 caracteres#
		fMiFileDescr.readline():
			while True:
				linea = f.readline()
				if not linea: break
				print linea
		fMiFileDescr.readlines():
			Lee todas las líneas del archivo y devuelve una lista con las líneas leídas.

	Funciones de escritura:
		fMiFileDescr.write(sText):
			Escribe una cadena de texto que sirve como parámetro.
		fMiFileDescr.writelines(lsTextList)
			El argumento es una lista de strings.

	Funciones de acceso al archivo:
		.tell()
			Devuelve la distancia en bytes desde el principio del fichero.
		.seek(iOffset, iPos)
			iOffset: 	número positivo o negativo a usar como desplazamiento.
			iPos:
				0 se refiere al principio del fichero
				1 posición actual
				2 final del fichero

Capítulo 13. Expresiones regulares
---------------------------------
13.1 Patrones
13.2 Usando el módulo re

Una expresión regular, regex or regexp, consiste en patrones que describen conjuntos de cadenas de caracteres.
El módulo re, regular expression, contiene funciones para
	· Search: buscar patrones dentro de una cadena
	· Match: comprobar si una cadena corresponde a un patrón.
		match(pattern, string, flags = 0)
	· Split: dividir la cadena
	· Sub: para sustituir el patrón por otra cadena
	· Compile
	· Groups
	· Findall
	· Finditer

13.1 Patrones
Para construir un patrón, se pueden utilizar metacaracteres como
	· . (punto)
		Equivale a un carácter.
	· (|) (paréntesis y barra vertical)
		Sirve para delimitar grupos.
		Sirve como operador OR entre patrones.
	· [-] (rango)
		Sirve para delimitar rangos de caracteres.
		El símbolo . no es metacaracter.
	· {,} (llaves)
		El número de veces o el rango de veces que puede aparecer.
	· ^ (negación)
	· + 1 ó más veces.
	· * 0 ó más veces.
	· ? 0 ó 1 vez.

Algunos ejemplos que ilustran su uso:
	13.re.Ej01.py -> match
	13.re.Ej02.py -> match .
	13.re.Ej03.py -> match . \.
	13.re.Ej04.py -> match \. ()
	13.re.Ej05.py -> match [-]
	13.re.Ej06.py -> match (|)
	13.re.Ej07.py -> match [-]
	13.re.Ej08.py -> match []
	13.re.Ej09.py -> match *
	13.re.Ej10.py -> match {}

13.1.1 Patrones extra
    · "\d": un dígito. Equivale a [0-9]
    · "\D": cualquier carácter que no sea un dígito. Equivale a [^0-9]
    · "\w": cualquier caracter alfanumérico. Equivale a [a-zA-Z0-9_]
    · "\W": cualquier carácter no alfanumérico. Equivale a [^a-zA-Z0-9_]
    · "\s": cualquier carácter en blanco. Equivale a [ \t\n\r\f\v]
    · "\S": cualquier carácter que no sea un espacio en blanco. Equivale a [^ \t\n\r\f\v]

13.1.2 Posiciones
    Patrón al principio: ^
    Patrón al final: $

13.2 Módulo re
13.2.1 Los flags
	Los flags modifican el comportamiento de las expresiones regulares.
		re.IGNORECASE: se ignoran si las letras son mayúsculas o minúsculas.
		re.VERBOSE: se ignoran los espacios y los comentarios en la cadena de la expresión regular.

13.2.2 El MatchObject que maneja re
	El módulo re devuelve un objeto MatchObject en caso de que haya acierto en la expresión regular y None si no hay acierto.
	La clase MatchObject tiene varios métodos de uso:
		.start()/.end()	Posición en que comienza y finaliza la subcadena reconocida.
		.group()/.groups() Grupos que propiciaron el reconocimiento de la cadena.
			.group(0)/.group() subcadena reconocida por la expresión regular al completo.
			.groups() devuelve todos los grupos menos el cero.
	Ejemplos:
		13.re.Ej11.py -> .group()
		13.re.Ej12.py -> .group(1)
		13.re.Ej13.py -> .groups()

13.2.3 re.search()
	Se busca cualquier parte de la cadena que se ajuste al patrón.
	El método .start() da la posición inicial.

13.2.4 re.findall()
	Devuelve una lista con las subcadenas que cumplieron el patrón.

13.2.5 re.finditer()
	Devuelve un iterador con el que consultar uno a uno los distintos MatchObject.

13.2.6 re.split(pattern, string, Nmax)
	Devuelve una lista con las subcadenas, de número máximo de elementos en que se quiere dividir la cadena.

13.2.7 re.sub(pattern, subtituting, stringToChange, Nmax)
	Substituye una subcadena en un string Nmax veces.
	Ejemplo: 13.re.Ej14.py

13.2.8 re.compile(pattern, flags=0)
	Crea un objeto tipo RegexObject.
	Sirve para reutilizar un patrón.
	Ejemplo: 13.re.Ej15.py
	Sobre este objeto RegexObject, se aplican los métodos .match, .search, .split, .sub, etc.

Capítulo 9. Sockets
-------------------
Los sockets son un concepto abstracto para implementar comunicaciones entre elementos de la red.
Un socket queda definido por:
	· IP address
	· Port listening
	· Protocol

En Python, el módulo socket los implementa.

Se clasifican en dos según el nivel 4 OSI:
	· Sockets de flujo (TCP) (socket.SOCK_STREAM)
	· Sockets de datagramas (UDP) (socket.SOCK_DGRAM)

O en tres según el nivel 3 OSI:
	· Sockets UNIX (socket.AF_UNIX)
	· Socket IPv4 (socket.AF_INET)
	· Socket IPv6 (socket.AF_INET6)

Constructor de un socket:
	MiSocket = socket.socket()
Parámetros:
	· Familia (por defecto, AF_INET)
	· Tipo (SOCK_STREAM)
	· Protocolo

Ejemplo: crear un servidor y un cliente
	I. Creación del servidor:
		Pasos para crear un servidor con sockets:
			1. Instanciar un socket
				MiSocketServer = socket.socket()
			2. bind: Indicar puerto
				MiSocketServer.bind(("localhost", 9999))
			3. listen: para aceptar conexiones entrantes
				MiSocketServer.listen(1) # número de conexiones entrantes >= 1
			4. accept: escuchar conexiones entrantes
				Bloquea la ejecución hasta que llega el mensaje.
				Al llegar un mensaje, devuelve un socket del cliente
					y un tupla que contiene el host y puerto de dicha
					conexión:
				MiSocketCliente, (HostCliente, PuertoCliente) = MiSocketServer.accept()
			5. send/sendfrom: envía datos (TCP/UDP)
			   recv/recvfrom: recibe datos (TCP/UDP)
				Rx = MiSocketCliente.recv(1024)
				print "Recibido: ", Rx
				Tx = Rx
				MiSocketCliente.send(Tx)
			6. Una terminada la conexión con el socket, se cierra con close.
				MiSocketCliente.close()
	II. Creación del cliente:
		1. Instanciar un socket:
			MiSocketCliente = socket.socket()
		2. connect: conectarnos al servidor:
			MiSocketCliente.connect("localhost", 9999)
		3. send/recv (TCP) / sendfrom/recvfrom (UDP):
			MiSocketCliente.send("hola")

Ejemplo completo:
	I. Servidor:
		La ejecución termina cuando el usuario escribe quit:
			import socket
			s = socket.socket()
			s.bind(("localhost", 9999))
			s.listen(1)
			sc, addr = s.accept()
			while True:
				recibido = sc.recv(1024)
				if recibido == "quit":
					break
				print "Recibido:", recibido
				sc.send(recibido)
			print "adios"
			sc.close()
			s.close()

	II. Cliente:
			import socket
			s = socket.socket()
			s.connect(("localhost", 9999))
			while True:
				mensaje = raw_input("> ")
				s.send(mensaje)
				mensaje == "quit":
				break
			print "adios"
			s.close()


Capítulo 10. Threads
--------------------
1. ¿Qué son los procesos y los threads?
2. El GIL
3. Threads en Python
4. Sincronización
5. Datos globales independientes
6. Compartir información

1. ¿Qué son los procesos y los threads?
En Python se pueden crear procesos con os.fork.
Los threads se crean dentro de un proceso y comparten recursos como la memoria (p.ej., variables globales).

2. El GIL (Global Interpreter Lock)
	Sólo un thread puede ejecutarse a la vez, independientemente del número de núcleos con que cuente la máquina.
	Ventaja: escribir extensiones para C.
	Desventaja: limita el rendimiento.

	Cada cierto número de instrucciones, la VM de Python en bytecode para la ejecución del thread y elige otro de entre los que esperan.
	Por defecto, cada 10 instrucciones hay cambio de thread. Se puede cambiar mediante sys.setcheckinterval.
	También se cambia cuando el hilo se pone a dormir con time.sleep o empieza una operación i/o.

	Otras opciones: módulo processing, escribir código en una extensión de C.

3. Threads en Python
	Módulo threads.
	Módulo threading: API de más alto nivel, más completa y orientada a objetos (se basa en el modelo de threads de Java). El método run contendrá el método que queremos que ejecute el thread.

	Ejemplo: threading
		import threading

		class MiThread(threading.Thread):
			def __init__(self, num):
				threading.Thread.__init__(self)
				self.num = num

			def run(self):
				print "Soy el hilo", self.num

	Llamada:
		print "Soy el hilo principal"

		for i in range(0, 10):
			t = MiThread(i)
			t.start() #El thread comienza a ejecutarse.
			t.join()  #Bloquea el hilo llamante hasta que finalice el thread que se llama.

	NOTA: si se startea un hilo en ejecución, salta una excepción.

	Ejemplo: forma recomendada de crear threads: instanciar Thread directamente.
		t = threading.Thread(target=imprime, args=(i, ), name = "nombre del thread")
			Parámetros del constructor:
				A. Clase ejecutable
					clase con el método especial __call__
				B. Función a ejecutar y los argumentos en una tupla (args) o diccionario (kwargs).
					t = threading.Thread(target=imprime, args=(i, ))
			Otros parámetros:
				name: nombre del thread
				verbose: imprima mensajes
				group: crear grupos de threads y trabajar a nivel de grupos.

		import threading

		def imprime(num):
			print "Soy el hilo", num

		print "Soy el hilo principal"
		for i in range(0, 10):
			t = threading.Thread(target=imprime, args=(i, ))
			t.start()

	Métodos interesantes:
		.isAlive comprueba si un thread sigue ejecutándose.
		.setName/getName para configurar el nombre del hilo.
		threading.enumerate lista de objetos threads que se están ejecutando.
		threading.activeCount consultar el número de threads ejecutándose.
		.setDaemon devuelve un booleano si se trata de un demonio.

	Clase Timer:
		Hereda de Thread y ejecuta el código de su método run después de un periodo de tiempo indicado como parámetro en su constructor.
		También incluye un método cancel mediante el que cancelar la ejecución antes de que termine el periodo de espera.

4. Sincronización
	Mecanismos de sincronización en threading:
		· locks, (mutex: mutual exclusion):
			Objetos con dos estados: adquirido o libre.
			Si está adquirido (locked), los demás threads que quieran adquirirlo quedarán bloqueados
		· locks reentrantes,
		· semáforos,
		· condiciones y
		· eventos.

	La clase Lock: representa el lock:
		.acquire()	para adquirir el candado.
			Devuelve True/False si adquirió o no el candado.
			Argumento: True/False si se quiere esperar a que se libere o no.
		.release()	para liberar el candado.

	Ejemplo:
		lista = []
		lock = threading.Lock()
		def anyadir(obj):
			lock.acquire()
			lista.append(obj)
			lock.release()

		def obtener():
			lock.acquire()
			obj = lista.pop()
			lock.release()
			return obj

	La clase RLock:
		Igual que Lock, pero el candado puede ser adquirido por el mismo thread varias veces.
		No quedará liberado hasta que se llame a release tantas veces como acquire.

	La clase Semaphore:
		También cuenta con acquire y release.
		Constructor de Semaphore:
			value 	Número máximo de threads que pueden acceder a la vez a la sección de código crítico.
					Cada llamada a acquire disminuye en uno el valor y release lo aumenta.
					value puede aumentar su valor si hay más releases que acquires.
					Para evitar esto, está la clase BoundedSemaphore, que da una excepción ValueError al superarse.
	Ejemplo:
		Múltiples threads se descargan datos de una URL, limitando el número de conexiones.
		semaforo = threading.Semaphore(4)

		def descargar(url):
			semaforo.acquire()
			urllib.urlretrieve(url)
			semaforo.release()

	Clase Condition:
		Útil para que los threads entren en una sección crítica en una condición o evento.
		Adecuadas para el problema del productor-consumidor.
		Constructor: usan un Lock como parámetro o crean un RLock si no se pasa ningún parámetro al constructor.
		Métodos:
			.acquire
			.release
			.wait
				Debe llamarse después de haber adquirido el candado con acquire.
				Libera el candado y bloquea el thread hasta que notify/notifyAll indican que se ha cumplido la condición que esperaba.
			.notify
				Se informa del evento a un solo thread.
			.notifyAll
				Se despiertan todos los threads.
	Ejemplo:
		lista = []
		cond = threading.Condition()

		def consumir():
			cond.acquire()
			cond.wait()
			obj = lista.pop()
			cond.release()
			return obj

		def producir(obj):
			cond.acquire()
			lista.append(obj)
			cond.notify()
			cond.release()

	Clase Event:
		Wrapper por encima de Condition.
		Coordinan threads mediante señales que indican que ha habido un evento.
		Carecen de acquire y release, son algo más abstractos.
		Métodos:
			.wait(tsecs)
				El thread esperante llama al método wait y se bloquea
			.set()
				El thread llama a set para despertar a los esperantes y desbloquearlos.
			.clear()
				Limpiar el flag que indica que se ha producido el evento.

	Ejemplo:
		import threading, time

		class MiThread(threading.Thread):
			def __init__(self, evento):
				threading.Thread.__init__(self)
				self.evento = evento

		def run(self):
			print self.getName(), "esperando al evento"
			self.evento.wait()
			print self.getName(), "termina la espera"

		evento = threading.Event()
		t1 = MiThread(evento)
		t1.start()
		t2 = MiThread(evento)
		t2.start()

		# Esperamos un poco
		time.sleep(5)
		evento.set()

	Equivalente a Java syncronized:
		Para que sólo un thread pueda acceder al método sobre el que se utiliza a la vez.
		def synchronized(lock):
			def dec(f):
				def func_dec(*args, **kwargs):
					lock.acquire()
					try:
						return f(*args, **kwargs)
					finally:
						lock.release()
				return func_dec
				return dec

		class MyThread(threading.Thread):
			@synchronized(mi_lock)
			def run(self):
			print "metodo sincronizado"

5. Datos globales independientes
	Los threads comparten las variables globales.
	También se pueden tener variables globales (todos los threads lo ven).
	Clase threading, método .local() crea un almacén de datos locales.
	Pasos a seguir:
		1. Instanciar la clase:
		2. Almacenar y obtener los valores a través de parámetros de la clase.
			datos_locales = threading.local()
			datos_locales.mi_var = "hola"
			print datos_locales.mi_var

	Ejemplo:
		El hilo principal imprime el atributo var, pero para el hilo 5 no existe y lanza una excepción.

		local = threading.local()
		def f():
			print local.var
		local.var = "hola"
		t = threading.Thread(target = f)
		print local.var
		t.start() #t no ha hecho local: t.local()
		t.join()

6. Compartir información
	Para compartir información entre threads está la clase Queue (FIFO).
	Constructor: parámetro con el tamaño máximo de cola, si no se indica, no hay límite.
	Métodos:
		.put(item[, bBlock][, timeout]) 	Añadir un elemento a la cola.
			bBlock: espera a que la cola deje de estar llena para introducirlo.
			timeout: tiempo máximo a esperar.
		.get([bBlock][, timeout])		Obtener el siguiente elemento.
			bBlock: espera a que haya algo en la cola para poder cogerlo.
			timeout: tiempo máximo a esperar.
	Timeout:
		Si termina y no realiza la operación, excepción:
			· Queue.Full
			· Queue.Empty

		.qsize()	Obtener tamaño de la cola.
		.empty()	Comprueba si está vacía.
		.full()		Comprueba si está llena.

		q = Queue.Queue()
		class MiThread(threading.Thread):
			def __init__(self, q):
				self.q = q
				threading.Thread.__init__(self)

			def run(self):
				while True:
				try:
					obj = q.get(False)
				except Queue.Empty:
					print "Fin"
					break
				print obj

			for i in range(10):
				q.put(i)

			t = MiThread(q)
			t.start()
			t.join()

Capítulo 11. Interactuar con webs
----------------------------------
	En Python hay dos módulos para leer datos de URL:
		urllib
		urllib2
	urllib2 es más completa, puede leer datos de una URL con protocolos como
		· HTTP
		· HTTPS
		· FTP
		· Gopher

	Clase urllib2:
		Al instanciarla, se crea un objeto que se maneja como un fichero, pero te abstrae de un socket.
		Métodos:
			f = urllib2.urlopen("http://www.python.org")
				Parámetro opcional: data para enviar info a direcciones HTTP usando POST (p.ej., responder a un formulario) (véase ejemplo más abajo)
			f.read() / .read(
			f.readline()
				Lee una línea.
			f.readlines()
				Lee todas las líneas y devuelve una lista con ellas.
			f.geturl()
			f.info()

	Ejemplo:
		import urllib2

		try:
			f = urllib2.urlopen("http://www.python.org")
			print f.read()
			f.close()
		except HTTPError, e:
			print "Ocurrió un error"
			print e.code
		except URLError, e:
			print "Ocurrió un error"
			print e.reason

	Errores co urllib2:
		· URLError
		· URLError HTTPError
			p.ej., El error 404

	Ejemplo loguearse en página por URL usando POST:
		data = 'password=contrase%A4a&usuario=manuel'
		urllib2.urlopen("http://www.python.org", data)

	También se puede usar el método urlencode de urllib:
		import urllib, urllib2
		params = urllib.urlencode({"usuario": "manuel",
		"password": "contraseña"})
		f = urllib2.urlopen("http://ejemplo.com/login", params)

	Descargar el contenido de una URL a un archivo local: urlretrieve de urllib

	Uso de GET con urlopen:
		params = urllib.urlencode({"usuario": "manuel", "password": "contraseña"})
		f = urllib2.urlopen("http://ejemplo.com/login" + "?" + params)

	Quedan aspectos que hay que practicar con ejemplos.


Capítulo 12. Serialización de objetos
------------------------
Serialización o marshalling: transformar el estado de un objeto para almacenarlo, recuperarlo y transportarlo.

Módulos Python: marshal, pickle, cPickle y shelve.

Marshal:
	· Trabaja con bytecode.
	· Tipos simples.
	· No hay seguridad ni comprobación de errores.

pickle:
	· Serializa casi cualquier objeto.
	· Seguridad básica
	· Rendimiento más lento.

cPickle:
	· pickle implementado en C.

Wrapper cPickle/pickle:
	try:
		import cPickle as pickle
	except ImportError:
		import pickle

Serializar un objeto: función dump(<objeto>, <fichero>, protocol)
	protocol = 0, 1, 2.

	try:
		import cPickle as pickle
	except ImportError:
		import pickle

	fichero = file("datos.dat", "w")
	animales = ["piton", "mono", "camello"]
	pickle.dump(animales, fichero)
	fichero.close()

	Ejemplo: Usando el parámetro protocolo
		try:
			import cPickle as pickle
		except ImportError:
			import pickle

		fichero = file("datos.dat", "w")
		animales = ["piton", "mono", "camello"]
		pickle.dump(animales, fichero, 2)
		fichero.close()

Cargar un objeto: load
	try:
		import cPickle as pickle
	except ImportError:
		import pickle

	fichero = file("datos.dat", "w")
	animales = ["piton", "mono", "camello"]
	pickle.dump(animales, fichero)
	fichero.close()
	fichero = file("datos.dat")
	animales2 = pickle.load(fichero)
	print animales2

Acceso a colección de objetos: módulo shelve
	import shelve
	animales = ["piton", "mono", "camello"]
	lenguajes = ["python", "mono", "perl"]
	shelf = shelve.open("datos.dat")
	shelf["primera"] = animales
	shelf["segunda"] = lenguajes
	print shelf["segunda"]
	shelf.close()

Capítulo 13. Bases de datos
---------------------------
1. DB API
	1.1 Variables globales
	1.2 Excepciones
	1.3 Uso básico de DB-API
	1.4 Tipos SQL
2. Otras opciones

1. DB API
Python Database API o DB-API y se recoge en el PEP 249 (http://www.python.org/dev/peps/pep-0249/).
En los ejemplos:
	SQLite
	módulo sqlite3

Para MySQL, driver DB API 2.0 MySQLdb (http://mysql-python.sourceforge.net/).

1.1 Variables globales
	Todo driver compatible con DB-API 2.0 debe tener 3 variables globales:
	· apilevel: string con la versión DB API que utiliza. Actualmente sólo puede tomar 1.0 o 2.0
	· threadsafety: entero de 0 a 3 que describe el módulo para el uso con threads.
		0: no se puede compartir el módulo entre threads sin utilizar algún tipo de mecanismo de sincronización.
		1: se puede compartir el módulo pero no las conexiones.
		2: módulos y conexiones, pero no cursores.
		3: totalmente thread-safe
	· paramstyle: informa sobre la sintaxis a utilizar para insertar valores en la consulta SQL de forma dinámica.
		· qmark: interrogaciones
			sql = "select all from t where valor = ?"
		· numeric: un número indicando la posición.
			sql = "select all from t where valor = :1"
		· named: el nombre del valor
			sql = "select all from t where valor=:valor"
		· format: especificadores de formato similares a los del printf de C.
			sql = "select all from t where valor=%s"
		· pyformat: similar al anterior, pero con las extensiones de Python.
			sql = "select all from t where valor=%(valor)"
	Para sqlite3:
		>>> import sqlite3 as dbapi
		>>> print dbapi.apilevel
		2.0
		>>> print dbapi.threadsafety
		1
		>>> print dbapi.paramstyle
		qmark

1.2 Excepciones
	Jerarquía de excepciones:
		StandardError
			Warning
			Error
				InterfaceError
				DatabaseError
				OperationalError
				IntegrityError
				InternalError
				ProgrammingError
				NotSupportedError

	StandardError:
		Superclase para todas las excepciones de DB API.
	Warning
		Excepción que se lanza para avisos importantes
	Error
		Superclase de los errores
	InterfaceError
		Errores relacionados con la interfaz de la base de datos, y no con la base de datos en sí.
	DatabaseError
		Errores relacionados con la base de datos.
	DataError
		Errores relacionados con los datos, como una división por cero.
	OperationalError
		Errores relacionados con el funcionamiento de la base de datos, como una desconexión inesperada.
	IntegrityError
		Errores relacionados con la integridad referencial.
	InternalError
		Error interno de la base de datos.
	ProgrammingError
		Errores de programación, como errores en el código SQL.
	NotSupportedError
		Excepción que se lanza cuando se solicita un método que no está soportado por la base de datos.

1.3 Uso básico de DB-API
	Conexión a la base de datos:
		connect(platform-dependant-parameters)
			sqlite3: connect(<file>)
					 connect(":memory:")
			MySQLdb:
				connect(host, port, user, password, db)
		Devuelve un objeto tipo Connection que representa la conexión con el servidor.
			>>> bbdd = dbapi.connect("bbdd.dat")
			>>> print bbdd
			<sqlite3.Connection object at 0x00A71DA0>
	Acceso a operaciones: cursor
		c = bbdd.cursor()
		Método execute de cursor:
			Parámetro una cadena de código SQL a ejecutar.
			Ejemplo:
				Crear una nueva tabla empleaos e insertar una tupla en ella.
				c.execute("""create table empleados (dni text,
						nombre text,
						departamento text)""")
				c.execute("""insert into empleados
					values ('12345678-A', 'Manuel Gil', 'Contabilidad')""")
	Commit/auto-commit:
		Si la DB soporta transacciones y están activadas, hay que llamar a commit; en otro caso, la base de datos estaría vacía.
		La DB puede contener también auto-commits.
		Si no soportan commit, debe haber un commit con implementación vacía.
		NOTA: si se llama a commit siempre, puede cambiarse de base de datos sólo con modificar la línea import (p.ej., de SQL a Postgress).
	Rollback:
		Para cancelar la transacción actual.
		Si no soporta rollback, su llamada producirá una excepción.

	Ejemplo completo:
		import sqlite3 as dbapi

		bbdd = dbapi.connect(bbdd.dat")
		cursor = bbdd.cursor()

		cursor.execute("""create table empleados (dni text,
						nombre text,
						departamento text)""")
		cursor.execute("""insert into empleados
						values ('12345678-A', 'Manuel Gil', 'Contabilidad')""")
		bbdd.commit()
		cursor.execute("""select * from empleados
						where departamento='Contabilidad'""")

		for tupla in cursor.fetchall():
			print tupla

	Consultas a la DB: execute y cursor
		También se puede llamar a los métodos de cursor
			· fetchone
			· fetchmany
			· fetchall

	Ejemplo:
		cursor.execute("""select * from empleados
				where departamento='Contabilidad'""")

		for resultado in cursor:
			print resultado

		· fetchone:
			Devuelve la siguiente tupla del conjunto resultado o None cuando no existen más tuplas.
		· fetchmany:
			Devuelve el número de tuplas indicado por el entero pasado como parámetro
			o bien el número indicado por el atributo Cursor.arraysize si no se pasa ningún parámetro (por defecto, 1)
		· fetchall
			devuelve un objeto iterable con todas las tuplas.

	Consultas: selects con substitución a DB API
		No usar métodos de cadena habituales, sino la substitución de parámetros de DB API.
		Ejemplo:
			http://www.mibanco.com/sucursales?ciudad=Madrid
			cursor.execute("""select * from sucursales where ciudad='" + ciudad + "'""")
			"http://www.mibanco.com/sucursales?ciudad=Madrid';SELECT * FROM contrasenyas"

		Substitución de parámetros: sqlite3
			Para sqlite3: paramstyle = qmark
			Inserta un signo de interrogación donde se quiera insertar un valor y un parámetro de tupla donde insertar los resultados.
				cursor.execute("""select * from sucursales where ciudad=?""", (ciudad,))
			Por último, al final del programa se debe cerrar el cursor y la conexion:
				cursor.close()
				bbdd.close()

1.4 Tipos SQL
	Para trabajar con tipos SQL, usar los constructores de la API:
		· Date(year, month, day): Para almacenar fechas.
		· Time(hour, minute, second): Para almacenar horas.
		· Timestamp(year, month, day, hour, minute, second): Para almacenar timestamps (una fecha con su hora).
		· DateFromTicks(ticks): Para crear una fecha a partir de un número con los segundos transcurridos desde el epoch (el 1 de Enero de 1970 a las 00:00:00 GMT).
		· TimeFromTicks(ticks): Similar al anterior, para horas en lugar de fechas.
		· TimestampFromTicks(ticks): Similar al anterior, para timestamps.
		· Binary(string): Valor binario.

2. Otras opciones
	En Python existen módulos propios para trabajar con bases de datos
	· Orientadas a objetos:
		· ZODB (Zope Object Database)
		· ORM (Object Relational Mapping Engine)
		· SQLAlchemy
		· SQLObject
		· Storm
	· JPython
		· Java databases
	· IronPython
		. .NET databases

Capítulo 14. Documentación
--------------------------
1. Docstrings
2. Pydoc
3. Epydoc y reStructuredText

1. Docstrings
	Atributo de cada función y clase.
	Ejemplo:
		def haz_algo(arg):
		"""Este es el docstring de la funcion."""
		print arg

		print haz_algo.__doc__

		haz_algo.__doc__ = """Este es un nuevo docstring."""
		print haz_algo.__doc__

	Se pueden consultar en tiempo de ejecución con help o con print.
	Ejemplo:
		>>> help(haz_algo)
		Help on function haz_algo in module __main__:
		haz_algo(arg)
		Este es un nuevo docstring

2. Pydoc
	pydoc es un módulo de ayuda que hace dos funciones de documentación:
		· mostrar la información como texto en la consola
		· generar archivos HTML como javadoc
		· mostar la info por Web server incluido en el módulo

	Pydoc sintaxis:
		pydoc.py nombre1 [nombre2 ...]
	muestra la documentación del
		· tema
		· módulo
		· clase
		· paquete
		· función
		· palabras clave (keywords)
	Si el parámetro es keywords, topics o modules, se listarán todos los parámetros indicados.

	Flags de pydoc:
		-w: guarda en HTML
			pydoc.py -w nombre1 [nombre2 ...]
		-k: busca una palabra
			pydoc.py -k xml
		-p: puerto del servidor HTTP
			pydoc.py -p puerto
		-g: interfaz gráfica
			pydoc.py -g
	Acceso a HTTP:
		http://localhost:puerto

3. Epydoc y reStructuredText
	Pydoc es un sistema simple y limitado.
	Para generar documentación:
		· Docutils
		· Epydoc
		· Sphinx

Docutils y reStructuredText:
	Creado por David Goodger.
	Genera documentación en formato reStructuredText.
	Formato de texto plano más usado en la comunidad Python, p.ej., para los PEP.
	Indicado para generar documentos a partir de archivos de texto.

EpyDoc
	Generador de documentación.
	Además de texto plano y epytext (formato de EpyDoc), soporta reStructuredText y Javadoc.
	En adelante, se usará
		· reStructureText como lenguaje de marcado
		· EpyDoc para generar documentos finales
	http://epydoc.sourceforge.net/
	Acceso:
		· script epydoc, aplicación de línea de comandos
		· epydocgui (epydoc.pyw en Windows), con interfaz gráfica
		· epydoc, uso como pydoc
	Ejemplo 1: docstrings de texto plano, sin marcado especial.
		"""Modulo para ejemplificar el uso de epydoc."""
		class Persona:
			"""Mi clase de ejemplo."""
			def __init__(self, nombre):
			"""Inicializador de la clase Persona."""
			self.nombre = nombre
			self.mostrar_nombre()

			def mostrar_nombre(self):
			"""Imprime el nombre de la persona"""
			print "Esta es la persona %s" % self.nombre

		class Empleado(Persona):
			"""Subclase de Persona."""
			pass

		if __name__ == "__main__":
			raul = Persona("Raul")

		Llamada:
			epydoc ejemplo.py

	Flags:
		--html:
			epydoc --html ejemplo.py
		--pdf: generarlo en LaTeX
			epydoc --pdf ejemplo.py
		--name: nombre del proyecto
		--url
			epydoc --name Ejemplo --url http://mundogeek.net ejemplo.py
		--graph classtree: muestra la clase base y subclases
		--graph callgraph: las llamadas entre funciones y métodos
		--graph uml-classtree: clases y subclases usando notación UML
		--graph all: todos los graph
			epydoc --graph all ejemplo.py
		--pstat: generar grafo de llamadas
			Requiere módulo profile o módulo hotshot
			epydoc --graph all --pstat profile.out ejemplo.py

	Marcado reStructuredText:
		*italica*
		**negrita** -> negrita
		"monoespacio"
		\* es un carácter especial
		Título
		======
		Subtitulo
		---------
		Lista no ordenada: * - +
			* Python
			* C
			* Java
		Lista ordenada:
			#. Python / 1. Python
			#. C
			#. Java
		Campos / fields:
			Empiezan y terminan por :.
			Tienen nombre y parámetro.
		Campos / fields: Funciones y métodos
			:param p:
				Un parámetro
			:Parameters:
				- item 1: item 1 explanation
				- item 2: item 2 explanation
			:type p: str
				Especifica el tipo esperado para el parámetro p.
			:return: True si son iguales
				Valor de retorno.
			:rtype: str
				Tipo del valor de retorno.
			:keyword p: Un parámetro
				Descripción del parámetro con valor por defecto y nombre p.
			:raise e: Si el parámetro es cero
				Describe las circunstancias para las que se lanza la excepción e.
		Campos / fields: Variables
			:ivar v: Una variable
				Descripción de la instancia v.
			:cvar v: Una variable
				Descripción de la variable estática de clase v.
			:var v: Una variable
				Descripción de la variable v del módulo.
			:type v: str
				Tipo de la variable v.
		Campos / fields: múltiples
			:Parameters: #:param :
				- item 1: item 1 explanation
				- item 2: item 2 explanation
			:Exceptions: #:except:
				- item 1: item 1 explanation
				- item 2: item 2 explanation
			:Variables: #:var v:
				- item 1: item 1 explanation
				- item 2: item 2 explanation
			:Ivariables: #:ivar v:
				- item 1: item 1 explanation
				- item 2: item 2 explanation
		Campos / fields: Notas
			:note: Una nota
				Una nota sobre el objeto.
			:attention: Importante
				Una nota importante sobre el objeto.
			:bug: No funciona para el valor 0
				Descripción de un error en el objeto.
			:warning: Cuidado con el valor 0
				Una advertencia acerca de un objeto.
			:see: Ver 'Python para todos'
				Para indicar información relacionada.
		Campos / fields: Estado
			:version: 1.0
				Versión actual del objeto.
			:change: Versión inicial
				Listado de cambios.
			:todo: Internacionalización
				Un cambio planeado para el objeto.
			:status: Versión estable
				Estado del objeto.
		Campos / fields: Autoría
			:author: Raul Gonzalez
				Autor o autores del objeto.
			:organization: Mundo geek
				Organización que creó o mantiene el objeto.
			:license: GPL
				Licencia del objeto.
			:contact: zootropo en gmail
				Información de contacto del autor.

Ejemplo:
		def function(arg1, arg2 = None):
			"""
			Blah Blah Blah L(funcion2).

			@param arg1: blah blah blah
			@type arg1: str
			@param arg1: blah blah blah
			@type arg1: str

			@return: blah blah blah
			@rtype: str
			"""

	Para utilizar reStructuredText en Epydoc, hay que indicarlo con __docformat__ en el código.
		__docformat__ = "restructuredtext"
	Las opciones son:
		epytext
		plaintext
		restructuredtext
		javadoc
	También se puede usar --docformat en la línea comandos.

	Ejemplo:
		"""Modulo para ejemplificar el uso de *epydoc*.
			:author: Raul Gonzalez
			:version: 0.1"""

		__docformat__ = "restructuredtext"

		class Persona:
			"""Modela una persona."""
			def __init__(self, nombre, edad):
				"""Inicializador de la clase `Persona`.
					:param nombre: Nombre de la persona.
					:param edad: Edad de la persona"""
				self.nombre = nombre
				self.edad = edad
				self.mostrar_nombre()

			def mostrar_nombre(self):
				"""Imprime el nombre de la persona"""
				print "Esta es la persona %s" % self.nombre

		class Empleado(Persona):
		"""Subclase de `Persona` correspondiente a las personas
			que trabajan para la organizacion.
				:todo: Escribir implementacion."""
		pass

		if __name__ == "__main__":
			juan = Persona("Juan", 26)

	Ejemplo 2:
	class Persona:
	"""Modela una persona."""
	def __init__(self, nombre, edad):
		"""Inicializador de la clase `Persona`.
			:Parameters:
				- `nombre`: Nombre de la persona.
				- `edad`: Edad de la persona.
		"""
		self.nombre = nombre
		self.edad = edad
		self.mostrar_nombre()


Capítulo 15. Tests
------------------
Doctest
unittest / PyUnit
	Preparación del contexto

Metodologías de pruebas:
	· Pruebas unitarias
	· Pruebas de integración
	· Pruebas de regresión

Doctest
	Permite combinar las pruebas con la documentación.
	Prueba unitarias + documentación: propicia:
		- realiza pruebas de forma sencilla
		- pruebas actualizadas
		- ejemplo de uso del código
		- ayuda a entender su propósito
	Doctest añade documentación con líneas que ejecutan pruebas unitarias:
		>>> código Python a ejecutar
		La respuesta esperada está en las líneas siguientes.
		Fin de prueba indicada por línea en blanco o final del docstring.
	Ejemplo:
		def cuadrados(lista):
		"""Calcula el cuadrado de los numeros de una lista
		>>> l = [0, 1, 2, 3]
		>>> cuadrados(l)
		[0, 1, 4, 9]
		"""
		return [n ** 2 for n in lista]

	Módulo testmod: Para ejecutar las pruebas.
		Parámetro name. Indica qué módulo a probar.
						Si no existe, se evalúa el módulo actual.
		Parámetro verbose=True

	Ejemplo:
		#Añadir el ejemplo anterior#
		def _test():
		import doctest
		doctest.testmod()

		if __name__ == "__main__":
			_test()

	Resultados:
		Si va mal, muestra
			· resultado obtenido
			· resultado esperado
		Si todo va bien, no se muestra nada a menos que se indique.
			-v al llamar al script
			Parámetro verbose=True en testmod()
		Ejemplo:
			Resultado con verbose.
			Trying:
			l = [0, 1, 2, 3]
			Expecting nothing
			ok
			Trying:
			cuadrados(l)
			Expecting:
			[0, 1, 4, 9]
			ok
			2 items had no tests:
			__main__
			__main__._test
			1 items passed all tests:
			2 tests in __main__.cuadrados
			2 tests in 3 items.
			2 passed and 0 failed.
			Test passed.

		Ejemplo 2:
			Se ha malescrito ** en lugar de *
			Se mostraría lo siguiente:
		*********************************************************
		File "ejemplo.py", line 5, in __main__.cuadrados
		Failed example:
		cuadrados(l)
		Expected:
		[0, 1, 4, 9]
		Got:
		[0, 2, 4, 6]
		*********************************************************
		1 items had failures:
		1 of 2 in __main__.cuadrados
		***Test Failed*** 1 failures.

	Sentencias anidadas: ...
	Ejemplo:
		def cuadrado(num):
			"""Calcula el cuadrado de un numero.
			>>> l = [0, 1, 2, 3]
			>>> for n in l:
			... cuadrado(n)
			[0, 1, 4, 9]
			"""
			return num ** 2
			def _test():
			import doctest
			doctest.testmod()

		if __name__ == "__main__":
		_test()

unittest / PyUnit
	Origen: Parte de la familia xUnit (Kent Beck, uno de los padres del EXtreme Programming).
		JUnit para Java.
		NUnit para .NET

	Uso de unittest:
		· clase que herede de unittest.TestCase.
		· Añadir métodos que empiecen por 'test'.
	Ejecutar las pruebas, llamar a la función main() del módulo: en alfabético, se ejecutan todos los métodos que comiencen por test.
	Resultados posibles:
		· OK
		· FAIL: AssertionError
		· ERROR: la prueba lanzó excepción distinta de AssertionError.
	Ejemplo:
		import unittest
		class EjemploPruebas(unittest.TestCase):
			def test(self):
				pass
		if __name__ == "__main__":
			unittest.main()

	Ejemplo 2: daría fail
		import unittest
		class EjemploPruebas(unittest.TestCase):
			def test(self):
				raise AssertionError()

		if __name__ == "__main__":
			unittest.main()

	Métodos de unittest para comprobaciones
	El parámetro msg es un string con lo que debe mostrar si falla.
		· assertAlmostEqual(first, second, places=7, msg=None) : Comprueba que los objetos pasados como parámetros sean iguales hasta el séptimo decimal (o el número de decimales indicado por places).
assertEqual(first, second, msg=None) : Comprueba que los objetos pasados como parámetros sean iguales.
assertFalse(expr, msg=None) : Comprueba que la expresión sea falsa.
assertNotAlmostEqual(first, second, places=7, msg=None) : Comprueba que los objetos pasados como parámetros no sean iguales hasta el séptimo decimal (o hasta el número de decimales indicado por places).
assertNotEqual(first, second, msg=None) : Comprueba que los objetos pasados como parámetros no sean iguales.
assertRaises(excClass, callableObj, *args, **kwargs) : Comprueba que al llamar al objeto callableObj con los parámetros definidos por *args y **kwargs se lanza una excepción de tipo excClass.
assertTrue(expr, msg=None) : Comprueba que la expresión sea cierta.
assert_(expr, msg=None) : Comprueba que la expresión sea cierta.
fail(msg=None) : Falla inmediatamente.
failIf(expr, msg=None) : Falla si la expresión es cierta.
failIfAlmostEqual(first, second, places=7, msg=None) : Falla si los objetos pasados como parámetros son iguales hasta el séptimo decimal (o hasta el número de decimales indicado por places).
failIfEqual(first, second, msg=None) : Falla si los objetos pasados como parámetros son iguales.
failUnless(expr, msg=None) : Falla a menos que la expresión sea cierta.
failUnlessAlmostEqual(first, second, places=7, msg=None) : Falla a menos que los objetos pasados como parámetros sean iguales hasta el séptimo decimal (o hasta el número de decimales indicado por places).
failUnlessEqual(first, second, msg=None) : Falla a menos que los objetos pasados como parámetros sean iguales.
failUnlessRaises(excClass, callableObj, *args, **kwargs) : Falla a menos que al llamar al objeto callableObj con los parámetros definidos por *args y **kwargs se lance una excepción de tipo excClass.

	Ejemplo: tratamiento de excepciones:
		import unittest
		def cuadrado(num):
			"""Calcula el cuadrado de un numero."""
			return num ** 2

		class EjemploPruebas(unittest.TestCase):
			def test(self):
			l = [0, 1, 2, 3]
			r = [cuadrado(n) for n in l]
			self.assertEqual(r, [0, 1, 4, 9])

		if __name__ == "__main__":
			unittest.main()

Preparación del contexto (el test fixture)
	Métodos de TestCase para construir y desconstruir el entorno.
	Se ejecutan antes y después de las pruebas definidas en esa clase.
	Los métodos son
		· setUp()
		· tearDown()

	class EjemploFixture(unittest.TestCase):
		def setUp(self):
			print "Preparando contexto"
			self.lista = [0, 1, 2, 3]
		def test(self):
			print "Ejecutando prueba"
			r = [cuadrado(n) for n in self.lista]
			self.assertEqual(r, [0, 1, 4, 9])
		def tearDown(self):
			print "Desconstruyendo contexto"
			del self.lista


Capítulo 16. Distribuir aplicaciones Python
-------------------------------------------
1 distutils
2 setuptools
	2.1 Integración con PyPI
	Eggs
	Otros cambios destacables

En Python hay dos módulos principales:
	· distutils
		Parte de la librería estándar.
	· setuptools
		Extensión de distutils.

distutils
	setup.py
		Script que instala la aplicación llamando a la función setup de distutils.core.
		Argumentos de setup.py:
			name: El nombre del paquete.
			version: El número de versión.
			description: Una línea describiendo el paquete.
			long_description: Descripción completa del paquete.
			author: Nombre del autor de la aplicación.
			author_email: Correo electrónico del autor.
			maintainer: Nombre de la persona encargada de mantener el paquete, si difiere del autor.
			maintainer_email: Correo de la persona encargada de mantener el paquete, si difiere del autor.
			url: Web de la aplicación.
			download_url: Url de la que descargar la aplicación.
			license: Licencia de la aplicación
		Argumentos que controlan los archivos y directorios que deben instalarse:
			· packages
			· py_modules
				Módulos que serán utilizados por el script principal.
			· scripts:
				Lista de cadenas que indica el nombre del módulo o módulos principales.
			· ext_modules
				Extensiones que utilice el programa: C, C++, Fortran...
		Ejemplo:
			Script con un solo archivo ejemplo.py
				from distutils.core import setup
					setup(name="Aplicacion de ejemplo",
						version="0.1",
						description="Ejemplo del funcionamiento de distutils",
						author="Raul Gonzalez",
						author_email="zootropo en gmail",
						url="http://mundogeek.net/tutorial-python/",
						license="GPL",
						scripts=["ejemplo.py"]
					)
		Ejemplo 2:
			Script principal ejemplo y módulo de apoyo apoyo.py.
				from distutils.core import setup
				setup(name="Aplicacion de ejemplo",
					version="0.1",
					description="Ejemplo del funcionamiento de distutils",
					author="Raul Gonzalez",
					author_email="zootropo en gmail",
					url="http://mundogeek.net/tutorial-python/",
					license="GPL",
					scripts=["ejemplo.py"],
					py_modules=["apoyo"]
				)

		Ejemplo 3:
			Instalar paquetes Python.
				from distutils.core import setup
					setup(name="Aplicacion de ejemplo",
					version="0.1",
					description="Ejemplo del funcionamiento de distutils",
					author="Raul Gonzalez",
					author_email="zootropo en gmail",
					url="http://mundogeek.net/tutorial-python/",
					license="GPL",
					scripts=["ejemplo.py"],
					packages=["gui", "bbdd"]
				)

	Instalación del programa:
		python setup.py install
	Acciones:
		· Módulos y paquetes (py_modules y packages) se instalan en el directorio Lib de Python:
		· Scripts al directorio scripts de Python.

	Distribución de la aplicación:
		Opción 'sdist' de setup.py
			· .tar.gz en Unix
			· .zip en Windows.

		Parámetro --formats
			bztar	.tar.bz2
			gztar	.tar.gz
			tar 	.tar
			zip		.zip
			ztar	.tar.Z
		Ejemplo:
			Generar un tar.bz2, un tar.gz y un zip.
				python setup.py sdist --formats=bztar,gztar,zip

		Parámetro bdist:
			Para generar un archivo de distribución binaria:
				python setup.py bdist

			Formatos soportados por bdist:
				rpm			RPM
				gztar		.tar.gz
				bztar		.tar.bz2
				ztar		.tar.Z
				tar			.tar
				wininst		Instalador Windows
				zip			.zip
		Ejemplo:
			Generar un rpm y un instalador de windows.
				python setup.py bdist --formats=wininst,rpm

		Para generar un .deb se utiliza el paquete stdeb.
			http://stdeb.python-hosting.com/

2 setuptools
	Añade funcionalidades nuevas:
		· Formato de archivo egg para distribución de aplicaciones Python.
		· Busca todos los paquetes que deben instalarse y añade posibles dependencias.
		· Permite instalar paquetes PyPI con un solo comando.
	Su uso es muy parecido a distutils, sólo cambia la sentencia de importación.
	Ejemplo:
		from setuptools import setup
			setup(name="Aplicacion de ejemplo",
			version="0.1",
			description="Ejemplo del funcionamiento de distutils",
			author="Raul Gonzalez",
			author_email="zootropo en gmail",
			url="http://mundogeek.net/tutorial-python/",
			license="GPL",
			scripts=["ejemplo.py"],
			)

2.1 Integración con PyPI
Eggs
	Equivalente a los archivos .jar en Java.
		· Multiplataforma
		· Permite manejar dependencias
		· Permite instalar varias versiones del mismo paquete.

	Instalar un archivo egg:
		easy_install mi-aplicacion.egg
	o pasarle la URL:
		easy_install http://mundogeek.net/mi-aplicacion.egg

	Para crear nuestros propios eggs, se usa el comando bdist_egg de setup.py:
		python setup.py bdist_egg

Otros cambios destacables
	Dependencias:
		setup.py: parámetro install_requires
			Es una lista de cadenas que indica los paquetes de los que depende la aplicación.
			Ejemplo:
				install_requires = ["apoyo"]
			Para indicar una versión concreta:
				install_requires = ["apoyo >= 1.0 < 2.0"]
		setup.py: parámetro dependency_links
				Repositorio donde acudir (p.ej., PyPI).
		Otras dependencias:
			Paquetes: 			setup_requires
			Tests:				tests_require
			Funcionalidades:	extras_require
	find_packages()
		Evita tener que listar los paquetes necesarios.
		Ejemplo: ver parámetro packages
			from ez_setup import use_setuptools
				use_setuptools()
				from setuptools import setup, find_packages
				setup(name="Aplicacion de ejemplo",
				version="0.1",
				description="Ejemplo del funcionamiento de distutils",
				author="Raul Gonzalez",
				author_email="zootropo en gmail",
				url="http://mundogeek.net/tutorial-python/",
				license="GPL",
				scripts=["ejemplo.py"],
				packages = find_packages()
			)

Crear ejecutables .exe: py2exe
	Requisitos de py2exe:
		· Programa principal
		· importar py2exe
		· argumentos console y windows para indicar el nombre del script(s) que se quiera convertir en ejecutables de consola o de interfaz gráfica.

		from distutils.core import setup
		import py2exe

		setup(name="Aplicacion de ejemplo",
			version="0.1",
			description="Ejemplo del funcionamiento de distutils",
			author="Raul Gonzalez",
			author_email="zootropo en gmail",
			url="http://mundogeek.net/tutorial-python/",
			license="GPL",
			scripts=["ejemplo.py"],
			console=["ejemplo.py"]
			)
	Compilación:
			python setup.py py2exe
		Se genera
			· un directorio build con las librerías compiladas.
			· un directorio dist, con los archivos de la aplicación.
				· uno o varios ejecutables con los scripts indicados en console y windows
				· un archivo python*.dll (intérprete de Python)
				· un archivo library.zip con pyc: módulos de la aplicación compilados
		Reducir el número de archivos:
			--bundle
				Añade las DLL a library.zip
			--bundle 2
				Añade las DLL y los pyd a library.zip
			--bundle 1
				Añade las DLL, los pyd y el intérprete
		Parámetros en setup.py: bundle_files
			from distutils.core import setup
				import py2exe
				setup(name="Aplicacion de ejemplo",
				version="0.1",
				description="Ejemplo del funcionamiento de distutils",
				author="Raul Gonzalez",
				author_email="zootropo en gmail",
				url="http://mundogeek.net/tutorial-python/",
				license="GPL",
				scripts=["ejemplo.py"],
				console=["ejemplo.py"],
				options={"py2exe": {"bundle_files": 1}}
			)
		Para inscrustar library.zip en ejecutable:
			zipfile=None

			from distutils.core import setup
				import py2exe
				setup(name="Aplicacion de ejemplo",
				version="0.1",
				description="Ejemplo del funcionamiento de distutils",
				author="Raul Gonzalez",
				author_email="zootropo en gmail",
				url="http://mundogeek.net/tutorial-python/",
				license="GPL",
				scripts=["ejemplo.py"],
				console=["ejemplo.py"],
				options={"py2exe": {"bundle_files": 1}},
				zipfile=None
			)