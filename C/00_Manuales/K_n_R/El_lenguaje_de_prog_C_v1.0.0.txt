NOTA: añadir paso de parametros con numero variable de argumentos.
 -------------------------------
| El lenguaje de programación C |
 -------------------------------
 por Kernighan & Ritchie

--------------------------------------------
Índice
1. Introducción general
	1.1 Palabras reservadas en C
	1.2 Almacenamiento de datos en C
	1.3 Tipos de datos
	1.4 Variantes de tipos de datos
	1.5 Estructuras de control
	1.6 Otras palabras reservadas en C
	Ej 01. Hola, mundo.
	Ej 02. Celsius to Farenheit
	Ej 03. Simple menu

2. Tipos, operadores y expresiones
	2.1 Variables y propiedades
	2.2 Constantes
		2.2.1 Secuencias de escape
	2.3 Casting
	2.4 Operadores
		2.4.1 Manejo de bit
		2.4.2 Asignación y expresiones
	Ej 01. Año bisiesto
	Ej 02. Conversor binario
	Ej 03. Entero a doble
	Ej 04. Entero a hexadecimal y a octeto

3. Control de flujo
	3.1 Expresión, proposición y declaración
	3.2 Sentencias de selección
		3.2.1 If-else
		3.2.2 Switch
	3.3 Sentencias de iteración
		3.3.1 Sentencia for
		3.3.2 Sentencia while
		3.3.3 Sentencia do-while
		3.3.4 Break y continue
		3.3.5 Goto y etiquetas
	Ej 01. Manejo de bits
	Ej 02. Binary search
	Ej 03. Reverse
	Ej 04. Shellsort
	Te 01. Template

4. Funciones y estructura del programa
	4.1 Conceptos principales
		4.1.1 Estructura
		4.1.2 Ámbito (scope rules)
		4.1.3 Encabezamiento (header)
	4.2 Almacenamiento de datos
	4.3 Recurrencia
	4.4 Preprocesador (macros)
		4.11.1 Inclusión de archivos
		4.11.2 Substitución de macros
		4.11.3 Inclusión condicional

5. Punteros y arrays
	5.1 Punteros y direcciones
	5.2 Punteros y argumentos de funciones
	5.3 Punteros y arrays
	5.4 Reserva y liberación de memoria (stdlib.h)
	5.5 Punteros a caracteres y funciones
	5.6 Array de punteros. Punteros a punteros
	5.7 Arrays multidimensinales
	5.8 Punteros contra arrays multidimensionales
	5.9 Argumentos en la línea de comandos
	5.10 Punteros a funciones

6. Estructuras
	6.1 Conceptos básicos sobre estructuras
	6.2 Estructuras y funciones
	6.3 Punteros a registros
	6.4 Arrays de estructuras
	6.5 Registros autorreferenciados
	6.7 Typedef
	6.8 Uniones
	6.9 Campos de bits
	
7. Entrada y salida
	7.1 Entrada y salida estándar
	7.2 Salida con formato: printf
	7.3 Listado de argumentos de longitud variable
	7.4 Entrada con formato: scanf
	7.5 Acceso a archivos
	7.6 Manejo de errores stderr y exit
	7.7 Entrada y salida de líneas
	7.8 Otras funciones
		7.8.1 Operaciones sobre cadenas <string.h>
		7.8.2 Prueba y conversión de clases de caracteres <chtype.h>
		7.8.3 Funciones ungetc y ungetch
		7.8.4 Ejecución de órdenes system(char *s)
		7.8.5 Administración de almacenamiento: malloc, calloc y free
		7.8.6 Funciones matemáticas <math.h>
		7.8.7 Generación de números aleatorios rand()

8. La interfaz con el sistema UNIX (syscalls.h)
	8.1 Descriptores de archivos
	8.2 Entrada y salida de bajo nivel: read y write
	8.3 Open, creat, close, unlink
	8.4 Acceso aleatorio: lseek
	8.5 Ejemplo: una relación de fopen y getc
	8.6 Ejemplo: listado de directorios
	8.7 Ejemplo: asignador de memoria
--------------------------------------------

/*=================================================*/
Capítulo 1. Introducción general
--------------------------------
1.1 Palabras reservadas en C
1.2 Almacenamiento de datos en C
1.3 Tipos de datos
	Notación CamelCase y notación húngara
1.4 Variantes de tipos de datos
1.5 Estructuras de control
1.6 Otras palabras reservadas en C
	
1.1 Palabras reservadas en C
	auto	break	case	char	const	 continue default
	do		double	else	enum	extern	 float	  for	
	goto	if		int		long	register return	  short
	signed	sizeof	static	struct	typedef	 union	  unsigned
	void	volatile 		while

1.2 Almacenamiento de datos en C
	auto
	extern
	register
	static
	modificador volatile
	modificador const

1.3 Tipos de datos
	char		int		float
	enum		struct	union
	typedef		void	*(puntero)
Notación CamelCase y notación húngara
	s char/string			e extern
	i int					r register
	e enum					s static
	r struct (register)		k const
	u union					l long
	f float					d double
	t Datatype

1.4 Variantes de tipos de datos
	const	double	float
	long	signed	unsigned

1.5 Estructuras de control
	break		case	continue
	default		do		else
	for			goto	if
	return		switch	while

1.6 Otras palabras reservadas en C
	sizeof()

Capítulo 2. Tipos, operadores y expresiones
-------------------------------------------
2.1 Variables y propiedades
2.2 Constantes
	2.2.1 Secuencias de escape
2.3 Casting
2.4 Operadores
	2.4.1 Manejo de bits
	2.4.2 Asignación y expresiones
--------------------------------------------

2.1 Variables y propiedades
	Variables simples:
		char	int		float (punto flotante)	double (notación científica)
	Propiedades
		short	long	signed	unsigned
	Variables estructuradas:
		array	struct	union	enum

2.2 Constantes
	Tipo int: 				const a = 1234
	Tipo long int: 			const a = 12345L 
	Tipo unsigned long int: const a = 12345UL 
	Tipo float:				const a = 123.4F
	Tipo double: 			const a = 1E-2
	Tipo long double: 		const a = 1.234

	Tipo octal:				const a = 037 (comienza por cero)
	Tipo oct unsigned long:	const a = 037UL
	Tipo hexadecimal:		const a = 0x1F
	Tipo hex unsigned long:	const a = 0x1FUL

2.2.1 Secuencias de escape
	Se deben escribir entre comillas simples:
	
	\a carácter de alarma (campana)		\b retroceso
	\f avance de hoja					\n nueva línea
	\r regreso de carro					\t tabulador horizontal
	\v tabulador vertical				\\ diagonal invertida
	\? interrogación					\' apóstrofo
	\" comillas							\ooo número octal (ej \012 = 10 en decimal)
	\xhh número hexadecimal				\0 carácter nulo (final de un string)

2.3 Casting
	Sintaxis: (nombre-de-tipo)expresión
		Ej: sqrt( (double) n ) //n es int y sqrt requiere double

2.4 Operadores
2.4.1 Manejo de bits
	& AND de bits
		Ej: n = n & 0x7F //0x7F = 0111 1111
			//hace cero todos los bits de n, menos los 7 de menor orden
	| OR de bits
		Ej: x = x | SET_ON 
			//fija a 1 todos los bits de x que son 1 en SET_ON
	<< Desplazamiento de bits
		x << 1 un desplazamiento de un bit
	~ Complemento a uno
		b = ~a
	^ XOR
		b ^= a; // b = b ^ a;
		
2.4.2 Asignación y expresiones
	expr1 op= expr2
		expr1 = (expr1) op (expr2)
		
	Operador ?
		expr1 ? expr2 : expr3
			Si expr1 es diferente a 0 (verdadero), ejecuta expr2.
			Si expr2 es 0 (falso), ejecuta expr3.
 

Capítulo 3. Control de flujo
----------------------------
3.1 Expresión, proposición y declaración
3.2 Sentencias de selección
	3.2.1 If-else
	3.2.2 Switch
3.3 Sentencias de iteración
	3.3.1 Sentencia for
	3.3.2 Sentencia while
	3.3.3 Sentencia do-while
	3.3.4 Break y continue
	3.3.5 Goto y etiquetas
-----------------------------
3.1 Expresión, proposición y declaración
	Una expresión (p.ej., x = 0 ó i++) se convierte en una proposición cuando va seguida de un punto y coma.
	Ej: Expresión: 		x = 0
		Proposición: 	x = 0;

3.2 Sentencias de selección
3.2.1 If-else
	if (expresión)
	{
		proposición
	}
	else if (expresión)
	{
		proposición
	}
	else
	{
		proposición
	}

3.2.2 Switch
	switch (expresión)
	{
		case exp-const: proposiciones
		case exp-const: proposiciones
		default: proposiciones
	}
	
	break provoca una salida inmediata del switch.
	return también es una forma válida para salir del switch.
	
	Ejemplo:
		switch(c) {
			case '0': case '1': case '2': case '3': case '4':
				n++;
				break;
			default: nother++; break;
		}

	Nota: para el switch, no pueden usarse strings (ej., case "hello" NO).

3.3 Sentencias de iteración
3.3.1 Sentencia for
	for (expr1; expr2; expr3)
	{
		proposición
	}

3.3.2 Sentencia while
	while (expresión)
	{
		proposición
	}
	
	es equivalente a 
	
	expr1;
	while ( expr2 )
	{
		proposición
		expr3;
	}

3.3.3 Sentencia do-while
	do
	{
		proposición
	}
	while (expresión);

3.3.4 Break y continue
	break sale del ciclo o del switch más interno.
	continue hace que se ejecute el siguiente ciclo.
	Por ejemplo:
		for ( i = 0; i < n; i++ )
		{
			if ( a[i] < 0 ) //ignora elementos negativos//
				continue; // el siguiente ciclo se ejecuta con i++
			// en el siguiente ciclo realizará la misma comprobación//
		}
	La proposición continue se emplea a menudo cuando la parte del ciclo que sigue es complicada.
	
3.3.5 Goto y etiquetas
	for (...)
	{
		goto error;
	}
	
	error: arregla el desorden
	
Capítulo 04. Funciones y estructura del programa
------------------------------------------------
	4.1 Conceptos principales
		4.1.1 Estructura
		4.1.2 Ámbito (scope rules)
		4.1.3 Encabezamiento (header)
	4.2 Almacenamiento de datos
	4.3 Recurrencia
	4.4 Preprocesador (macros)
		4.11.1 Inclusión de archivos
		4.11.2 Substitución de macros
		4.11.3 Inclusión condicional

4.1 Conceptos principales
4.1.1 Estructura
	Una función en C tiene la estructura
		<tipo> function(<tipo> <variable>, ...)

4.1.2 Ámbito de la función (scope rules)
	En C no existe el anidamiento de funciones.
	El ámbito de una función es el archivo .c o .h donde esté definido y declarado.

	El «scope» es el rango del programa dentro del cual se puede usar el nombre. Por ejemplo, para una variable automática declarada al principio de una función, el alcance es la función dentro de la cual está declarado el nombre. Las variables locales con el mismo nombre que estén en funciones diferentes no tienen relación. Ibídem para los parámetros de una función, los cuales son variables locales.
	
	Ejemplo:
	main() {...}
	
	//Definición de variables//
	int sp = 0;
	double val[MAXVAL];
	
	void push( double f ) {...}
	
	double pop( void ) {...}
	
	//Declaración de variables externas//
	extern int sp;
	extern double val[];
	
	Hay que distinguir entre la declaración de una variable externa y su definición. Una declaración expone las propiedades de una variable (principalmente su tipo); una definición también provoca que se reserve un espacio para almacenamiento.
	
	//Declaración de variables externas//
	extern int sp;
	extern double var[];
	
	Esta declaración no crea las variables ni les reserva espacio en memoria. Su tamaño se determina en otro lugar. Sólo debe existir una definición de una variable externa entre todos los archivos que forman un programa fuente; otros archivos pueden contener declaraciones extern para tener acceso a ellas. (También puede haber declaraciones extern en el archivo que contiene la definición.) Los tamaños de los arrays deben ser especificados con la definición, pero es optativo hacerlo en una declaración extern. La inicialización de una variable externa sólo va con su definición.
	
4.1.3 Encabezamiento (header)
	Los archivos header contienen las definiciones y declaraciones compartidas entre archivos.

4.2 Almacenamiento de datos
	Hay cuatro tipos de almacenamiento de datos con dos modificadores, que afectan a la visibilidad de la función y a su tipo de almacenamiento:
	4.2.1 auto
	4.2.2 extern
	4.2.3 register
	4.2.4 static
	4.2.5 Modificador const
	4.2.6 Modificador volatile
	
	Para más información, véase el artículo PDF de "Almacenamiento - aspectos físicos y lógicos".
	
4.2.1 Almacenamiento automático
	Sintaxis: [auto] <tipo> <nombre_variable>;
	Son variables locales, se reservan en tiempo de compilación, se crean en tiempo de ejecución y se destruyen una vez terminada la ejecución de la función, es decir, su ámbito.

4.2.2 Almacenamiento extern
	Sintaxis:	extern <tipo> <nombre_variable>;
				[extern] <tipo> <nombre_de_función>(<lista_parámetros>);
	Este especificador se usa para indicar que el almacenamiento y valor de una variable o la definición de una función están definidos en otro módulo o fichero fuente. 
	Ejemplo:
		ClaseAlmacenStatic [Eclipse]

4.2.3 Almacenamiento register
	Sintaxis: 	register <tipo> <nombre_variable>;
	Indica al compilador una preferencia para que el objeto se almacene en un registro de la CPU, si es posible, con el fin de optimizar su acceso, consiguiendo una mayor velocidad de ejecución.
	Su ámbito es igual que las variables automáticas.
	Un objeto de este tipo no reside en memoria, y por lo tanto no tiene una dirección de memoria, es decir, no es posible obtener una referencia a un objeto declarado con el tipo de almacenamiento en registro.

4.2.4 Almacenamiento static
	Sintaxis: 	static <tipo> <nombre_variable>;
				static <tipo> <nombre_de_función>(<lista_parámetros>);
	Cuando se usa en la declaración de objetos, este especificador hace que se asigne una dirección de memoria fija para el	objeto mientras el programa se esté ejecutando. 
	Es decir, su ámbito temporal es total. 
	Las variables estáticas tienen un ámbito local con respecto a su accesibilidad, pero temporalmente son como las variables externas.
	Ejemplo:
		int funcion();

		int main() {
			for(int i = 0; i < 10; i++)
				cout << "Llamada " << i+1 << ": " << funcion() << endl;
			return 0;
		}

		int funcion() {
			static int x=10;

			x++;
			return x;
		}
////////////EJemeplo hola mundo static////////////////////
#ifndef STDLIB
  #define STDLIB 
    #include <stdio.h>
    #include <stdlib.h>
#endif

static int func1(int i)
{
   return i;
}

int func2(int i)
{
  return 2*i;
}

static int i = 3;

int func3(int i)
{
  static int iReturn = 4;

  iReturn +=1;

  return iReturn*i;
}
/////////////////////////////////////////////////////////////

4.2.5 Modificador const
	El modificador const crea nuevos tipos de objetos, e indica que el valor de tales objetos no puede ser modificado por el programa. 	
	Sintaxis:	const <tipo> <variable> = <inicialización>;
				const <tipo> <variable_agregada> = {<lista_inicialización>};
				<tipo> <nombre_de_función> (const <tipo>*<nombre-de-variable> );
				const <tipo> <nombre_de_función>(<lista_parámetros>);
				<tipo> <nombre_de_función_miembro>(<lista_parámetros>) const;

4.2.6 Modificador volatile
	Sintaxis: 	volatile <tipo> <nombre_variable>;
				<identificador_función> ( volatile <tipo> <nombre_variable> );
				<identificador_función> volatile;
	
	Este modificador se usa con objetos que pueden ser modificados desde el exterior del programa, mediante procesos externos. Esta situación es común en programas multihilo o cuando el valor de ciertos objetos puede ser modificado mediante interrupciones o por hardware.
	
4.3 Recurrencia
	C permite funciones recursivas (el diccionario de la RAE indica explícitamente que debe decirse "recurrentes" en lugar del barbarismo 'recursivo').
	Ejemplo:
		/**
			\title Función de Fibonacci
					F(0) = 0;
					F(1) = 1;
					F(n) = F(n-1) + F(n-2);
		*/
		int f_fibonacci(int n)
		{
			if (n == 0)
			{
				return 0;
			}
			else if (n == 1)
			{
				return 1;
			}
			else
			{
				return f_fibonacci(n-1) + f_fibonacci(n-2);
			}
		}
4.4 Preprocesador (macros)
4.11.1 Inclusión de archivos (#include)
	#include "filename" (ej: #include "/bin/library")
		Las comillas indican que el compilador debe buscar en el directorio donde el programa fuente fue encontrado.
	#include <filename>
		Los símbolos indican que debe buscarse en el directorio del PATH del sistema operativo.

4.11.2 Substitución de macros (#define y #undef)
	La sentencia
		#define nombre texto a reemplazar
produce que todas las ocurrencias del token nombre sean substituidas por "texto a reemplazar" (sin las comillas). Esta labor la hace el precompilador.
	Si se desea que se reemplace por varias líneas, hay que usar la barra invertida \.
	Ejemplo:	
		#define nombre texto \
						a \
						reemplazar
	Las substituciones se realizan a lo largo de todo el texto, pero NO tienen lugar si están en cadenas de caracteres (strings) entre comillas ni tampoco si un token contiene el token definido.
	Ejemplo: 
		#define YES yes
		No se aplicaría a printf("YES") ni tampoco al token YESMAN.
	
	Macros con argumentos:
	Es posible definir macros con argumentos.
	Ejemplo:
		#define max(A, B) ((A) > (B) ? (A) : (B))
	Así, max se descompone en cada llamada por su definición, a diferencia de una llamada a función.
	Esta macro puede servir para cualquier tipo de dato, no importa cual sea.

	Macro #undef
	Los tokens pueden ser indefinidos, por ejemplo, para asegurar de que una rutina es realmente una función, no una macro.
	Ejemplo:
		#undef getchar
		int getchar(void){...}
	
	Macros en strings
	Los argumentos de una macro no se remplazan dentro de strings entrecomillados. Sin embargo, sí hay una forma de que un argumento pueda incluirse en un string, por ejemplo, para imprimir datos durante la depuración, usando el token #.
	Ejemplo:
		#define dprint(expr) printf(#expr " = %g\n", expr)
	Al ser invocado, por ejemplo,
		dprint(x/y);
será substituido por
		printf("x/y" " = &g\n", x/y);
lo que concatenando los strings termina en 
		printf("x/y = &g\n", x/y);
	
	El operador ## de concatenación
	Este operador proporciona un método para concatenar argumentos en la expansión de la macro.
	Ejemplo:
		#define paste(front, back) front ## back
		paste(name, 1) produce name1
		
	Las reglas para el encadenamiento de ## son arcanas, pueden verse en el apéndice 1.
	
4.11.3 Inclusión condicional (#if, #elif, #else, #ifdef, #ifndef, #endif)
	Es posible controlar la expansión de macros con sentencias condicionales.
	Ejemplo:
		//#if non-zero expression (true) is evaluated until #endif, #elif or #else
		#ifndef HDR
			#define A 1
		#elif !defined(HDR)
			#define B 1
		#else
			#define A 3
		#endif
	
	Esta secuencia prueba que el nombre SYSTEM para decidir qué versión de la cabecera incluir:	
	#if SYSTEM == SYSV
		#define HDR "sysv.h"
	#elif SYSTEM == BSD
		#define HDR "bsd.h"
	#elif SYSTEM == MSDOS
		#define HDR "msdos.h"
	#else
		#define HDR "default.h"
	#endif
	#include HDR
	
Capítulo 5. Punteros y arrays
------------------------------
5. Punteros y arrays
	5.1 Punteros y direcciones
	5.2 Punteros y argumentos de funciones
	5.3 Punteros y arrays
	5.4 Reserva y liberación de memoria (stdlib.h)
	5.5 Punteros a caracteres y funciones
	5.6 Array de punteros. Punteros a punteros
	5.7 Arrays multidimensinales
	5.8 Punteros contra arrays multidimensionales
	5.9 Argumentos en la línea de comandos
	5.10 Punteros a funciones
---------------------------------------------------
5.1 Punteros y direcciones
	Nomenclatura básica de los punteros
	int *p; //definición de puntero a int
	& es el símbolo ampersand para obtener la dirección de un puntero
	ejemplo: &p = 1024 p = 2048 *p = 7
	* es el operador de indirección o desreferencia
	*p es el contenido de la posición de memoria apuntada por p.
	(*p)++  ++*p *p+=1
	Ejemplo:
		1023 = 0x03FF 	| p = 2048 	|
				.
				.
				.
		2048 = 0x0800	| p = 7		|
		p = 2048
		*p = 7

5.2 Punteros y argumentos de funciones
	Paso de argumentos por referencia:
	void swap(int *px, int *py)
	swap(&a, &b)
	swap(pa, pb)
	
5.3 Punteros y arrays
	Definición de punteros y arrays:
	int a[10];
	 // a: 	-----------------------------
	 //		| 	|	|	|	|  ...	|	|
	 //		-----------------------------
	 //		  0	  1	  2	  3	   ... 	  9
	
	int *pa; //sin memoria reservada
	pa = a; // el puntero apunta al array
	pa = &a[0] // el puntero apunta a la primera posición del array (equivalente al anterior)
	int x;
	x = *pa; //x = a[0];
	(pa + i) //apuntar a la i-ésima posición del array
	*(pa + i) //contenido de la i-ésima posición del array
	Las siguientes expresiones son equivalentes:
	&a[i] = (a + i) //equivalente
	pa[i] = *(pa + i) //equivalente
	a[i] = *(pa + i) //equivalente
	
	Arrays como argumentos de funciones: se pasa un puntero a la posición inicial del array
	Strings:
		strlen("hola, mundo"); //constante cadena//
		strlen(array);	//char array[100]//
		strlen(&array[0]);	//igual que el anterior//
		strlen(ptrarray);	//char *ptr//
	
	Los dos argumentos son equivalentes:
	f(int arr[]) {...} 
	f(int *arr ) {...}
	
5.4 Reserva y liberación de memoria (stdlib.h)
	Funciones de reserva y liberación de memoria (biblioteca stdlib):

	Función malloc (memory allocation)
	void *malloc(size_t size);
	ptr = (int*)malloc(sizeof(int));
	free(ptr); //Para liberar la memoria reservada.
	
	Función calloc (consecutive allocation)
	void* calloc(size_t nmemb, size_t size);
	int *ptr;
	ptr = (int*)calloc(7, sizeof(int));
	NOTA: calloc con strings, hace que escriba el '\n' al final.

5.5 Punteros a caracteres y funciones
	char* pmessage;
	pmessage = (char*)malloc(strlen("hello, world")*sizeof(char));
	
	Librería <string.h>
		void strcpy(char *s, const char*t);
		int strcmp(char *s, char *t);
			  0 sii son iguales
			> 0 sii s > t
			< 0 sii s < t

	*p++ = val; //primero asigna, luego incrementa
	val = *--p; //primero decrementa, luego asigna

5.6 Array de punteros. Punteros a punteros
	Pueden definirse punteros a otros punteros, es decir, arrays de punteros.
	Ejemplo:
		//Puntero doble
		char **c;
		c = (char**)malloc(sizeof(char*));
		//Array de punteros
		char *lineptr[MAXLINES]; /* pointers to text lines */
	
5.7 Arrays multidimensinales
	f(int daytab[][13]) {...}
	f(int (*daytab)[13]) {...}	//equivalente al anterior
	
	Warning:
	int (*daytab)[13] 	//puntero a un array de punteros a int repetido 13 veces
			  0	  1	   ...    12
			---------------------
		p ->|	|	|  ...	|	|
			---------------------
			  |	  |			  |
			 int int   ...	 int
			  
	int *daytab[13]		//array de 13 posiciones de punteros a int
			 0	  1	   ...    12
			---------------------
		    |	|	|  ...	|	|
			---------------------
			  |	  |			  |
			 int int   ...	 int

5.8 Punteros contra arrays multidimensionales
	char *name[] = {"Mes ilegal","Enero","Febrero","Marzo"};
	c = (char**)malloc(7*sizeof(char*));
	
5.9 Argumentos en la línea de comandos
int main(int argc, char *argv[]);
	int argc: argument count
		Número de argumentos con los que se invocó desde el prompt.
		
	char *argv[]: argument vector
		Puntero a array de punteros a string.
		
	Ejemplo:
		C:\>echo hello, world

		argc = 3 (echo + hello, + world)
		argv	 -----	    -------- 
		  · ->  |  0  | -> |"echo\0"|
				 -----	    ----------- 
				|  1  | -> |"hello,\0" |
				 -----	    ----------- 
				|  2  | -> |"world\0"  |
				 -----		-----------
				| NULL|
				 -----
	Ejemplo:
----------------------------------------------------------
		#include <stdio.h>
		#include <stdlib.h>

		int main(int argc, char *argv[])
		{

			printf("\n El numero de parametros del comando es: %d", argc);
			int iI;
			for (iI = 0; iI < argc; iI++)
			{
				printf("\n Argumento numero %d: %s", iI, argv[iI]);
			}

			printf("\n");
			system("pause");
			return EXIT_SUCCESS;
		}
----------------------------------------------------------

5.10 Punteros a funciones
	Igual que existe el concepto de puntero a una variable, existe el concepto de puntero a una función.
	Igual que con un puntero a una variable puede evaluarse su valor (siendo necesario el uso de castings), con un puntero a una función pueden evaluarse funciones (también se usa el casting).
	Operaciones:
		- Definición
		- Llamada
		- Asignación
		- Paso como parámetro (formal, actual)
	Ejemplo:
		Resolver el algoritmo de Fibonacci de forma iterativa y recursiva. Con un puntero a una función se evalúa cada solución.
		//Definición del puntero a función//
			int (*f)(const int ); //Puntero a función llamada f, cualquier función con un argumento const int y devuelve un int//
			int (*f)(const int n);//Otra forma de definirlo, más recomendable la anterior//
			//Como parámetro formal de una función//
			int f_fibonacci(int (*f)(const int n), const int n);
		//Uso (asignación) del puntero a función (importante el casting)//
			f = (int (*)(int))(f_fibonacci_ite)(n); //Llamada a Fibonacci iterativo con casting//
			f = (int (*)(int))(f_fibonacci_ite(n)); //Otra forma de llamarlo (menos recomendada)//
		//Obtención del valor (en este caso, int) de una función//
			printf("\n \t %d", (int)(*g));
			int a = (int)(*g); //importante casting//
	
	Si se quiere usar como parámetro de una función a la que después se implementa y también se llama desde otra función hay que seguir las siguientes reglas:
		//Como parámetro formal de una función//
		int f_fibonacci(int (*f)(const int n), const int n);
		//Llamada a la función (parámetro actual) (importante el casting)//
		int result = f_fibonacci( ( int (*)(const int ) ) f_fibonacci_rec, i_orden);
		//Implementación de f_fibonacci, llamada a f con sus parámetros//
		(*f)(n);
	
	Ejemplo 2:
		//Función quicksort//
		//Requiere una función de comparación que depende de lo que se quiera ordenar//
		void qsort(void *base, size_t nmemb, size_t tamanyo, int (*comparar)(const void *, const void *));
	Warning:
		int *comp(void *, void *) //puntero a int
		int (*comp)(void *, void *) //puntero a función


Capítulo 6. Estructuras
-----------------------
6.1 Conceptos básicos sobre estructuras
6.2 Estructuras y funciones
6.3 Punteros a registros
6.4 Arrays de estructuras
6.5 Registros autorreferenciados
6.7 Typedef
6.8 Uniones
6.9 Campos de bits

6.1 Conceptos básicos sobre estructuras
	Una estructura, también conocida como registro, almacena campos de un tipo definido a los que puede accederse después como el operador "." (sin comillas) para variable estáticas y "->" para punteros a los registros.
	Ejemplo:
		struct point
		 {
		   int x;
		   int y;
		 };
	
	Acceso a los campos, también conocidos como miembros del registro, mediante el operador ".",
		struct point pt1; //declaración de variable registro.
		pt1.x = 0; 	//Acceso al campo x.
		pt1.y = 56;	//Acceso al campo y.

	Una declaración de estructura que no está seguida por una lista de variables no reserva espacio de almacenamiento sino que simplemente describe una plantilla o la forma de una estructura.
	Ejemplo:
		struct point pt; //struct definido anteriormente.
		
		struct point x = {0, 0};
	
Anidamiento de registros
	Los registros pueden anidarse unos a otros.
	Ejemplo:
		Un registro tipo rectángulo que contiene los dos puntos que lo identifican.
		struct rect
		{
			struct point p1;
			struct point p2;
		};
		struct rect screen;
		screen.p1.x = 0 //coord x del elemento p1 del rectángulo.

6.2 Estructuras y funciones
	Operaciones legales sobre las estructuras:
		- copiarla (incluido pasarlas como argumentos y regresar valores a funciones)
		- asignarla como unidad
		- tomar su dirección con &
		- tener acceso a sus elementos
		x No se pueden comparar estructuras 

	Ejemplo:
		Función que devuelve un struct point.
			struct point makepoint(int x, int y)
			{
				struct point temp;

				temp.x = x;
				temp.y = y;

				return temp;
			}

6.3 Punteros a registros
	struct point *pp
	Referenciar un apuntador a una estructura
		(*pp).x
ya que la precedencia de . es mayor que la de *
		*pp.x = *(pp.x) (x tendría que ser un puntero)
	Otra opción es usar el operador ->
		p->miembro de la estructura
	Ejemplo:
		pp->x = 5;
		pp->y = 65;

6.4 Arrays de estructuras
	Un array de registros es perfectamente posible.
	Ejemplo:
		struct key
		{
			char *keyword, 	//string que contiene la palabra.
			int count		//número de veces que se ha pulsado
		} keytab[NKEYS] = {{"auto",0},{"break",0},{"case",1}};
	
	NOTA: sizeof
	El lenguage C proporciona un operador unario en tiempo de compilación llamado sizeof que se puede emplear para calcular el tamaño de cualquier objeto:
		sizeof <objeto> // objeto puede ser variable, array o estructura.
		sizeof(nombre de tipo) // tipo básico (int, double, char) o definido
dan un entero igual al tamaño en bytes del tipo u objeto especificado (retorna un tipo size_t definido en el header <stddef.h>).
		 #define NKEYS (sizeof keytab / sizeof(struct key))
		 #define NKEYS (sizeof keytab / sizeof keytab[0])

	Un sizeof no se puede utilizar en una línea #if, debido a que el preprocesador no analiza nombres de tipos. Puesto que #define no es evaluada por el preprocesador y aquí el código es legal.

	Si p es un puntero a una estructura, la aritmética con p toma en cuenta el tamaño de la estructura, así que p++ incrementa p con la cantidad correcta para obtener el siguiente elemento del array de estructuras y la prueba detiene el ciclo en el momento correcto.

Sin embargo, no hay que suponer que el tamaño de una estructura es la suma de los tamaños de sus miembros. Debido a requisitos de alineación para diferentes objetos, podría haber "huecos" no identificados dentro de una estructura.
	Por ejemplo, si un char es de 1 B y un int de 4 B, la estructura
		struct
		{ 	char c;
			int i;
		}
bien podría requerir 8 B, no 5 B. El operador sizeof regresa el valor apropiado.

6.5 Registros autorreferenciados
	Los registros pueden autorreferenciarse en sus campos internos.
	Ejemplo: estructura de árbol 
		struct node_r //el nodo del árbol//
		{
			char *palabra; 			//puntero hacia el texto//
			int count;				//número de ocurrencias//
			struct node_r *l_child;	//hijo izquierdo//
			struct node_r *r_child;	//hijo derecho//
		};

6.7 Typedef
	La palabra reservada typedef se utiliza para crear nuevos tipos de datos.
	Sintaxis:
		typedef <tipo> <nombre de tipo>
	Ejemplo:
		typedef struct node_r *p_nodo;
		typedef struct node_r	//el nodo del árbol//
		{
			char *palabra;	//apunta hacia el texto//
			int count;		//número de ocurrencias//
			p_nodo left;	//hijo izquierdo//
			p_nodo right;	//hijo derecho//
		} node_t;
		
	Ejemplo 2:
		Tipo de dato definido para funciones con dos parámetros char* y que devuelven un int.
			typedef int (*AAF)(char *, char *);
el cual se puede usar en contextos como
			AAF strcmp, numcmp; //ejemplo del capítulo 5//

	Hay dos razones para usar typedef, además de las puramente estéticas:
		· Parametrizar un programa contra los problemas de transportabilidad.
			Ejemplo: size_t y ptrdiff_t de la biblioteca estándar.
		· Proporcionar mejor documentación para un programa.

6.8 Uniones
	Una unión es una variable que puede contener (en momentos diferentes) objetos de diferentes tipos y tamaños, y el compilador hace el seguimiento del tamaño y requisitos de alineación. Las uniones proporcionan una forma de manipular diferentes clases de datos dentro de una sola área de almacenamiento, sin incluir en el programa ninguna información dependiente de la máquina.
	Ejemplo:
		union u_tag
		{
		  int ival;
		  float fval;
		  char *sval;
		} u;

Sintácticamente, se tiene acceso a los miembros de una unión con
  nombre-union.elemento
  apuntador-union->miembro
Igual que las estructuras.
	Ejemplo:
		u.ival = 5; //valor entero.
		u.fval = 5.2; //valor flotante (el valor entero no permanece)
		//Con punteros
		union u_tag *ptr_u;
		ptr_u->ival = 7;
		ptr_u->fval = 5.2;

	Una unión puede representarse dentro de estructuras y arrays:
	Ejemplo:
		struct
		{
			char *name;
			int flags;
			int utype;
			union
			{
				int ival;
				float fval;
			    char *sval;
			} u;
		} symtab[NSYM];

6.9 Campos de bits
	Un registro puede usarse para crear un campo de flags de un bit para almacenar información de estado.
	Esto puede realizarse de dos formas:
		1. Usando máscaras, correspondientes a posiciones relevantes de bits.
			//Opción 1//
			#define KEYWORD		01
			#define EXTERNAL	02
			#define STATIC		04
			//Opción 2//
			enum{ KEYWORD = 01, EXTERNAL = 02, STATIC = 04 };
			
			Para operar sobre los datos, potencia de dos, se usan los operadores de
				· corrimiento
				· enmascaramiento
				· complemento
			Ejemplo:
				flags |= EXTERNAL | STATIC; 	//enciende los bits EXTERNAL y STATIC en flags//
				flags &= ~(EXTERNAL | STATIC);	//apaga los bits EXTERNAL y STATIC en flags//
				if ((flags & (EXTERNAL | STATIC)) == 0) //verdadero si ambos bits están apagados//
		2. Usando campos de bits, conjunto de bits adyacentes dentro de una unidad de almacenamiento.
			//campos de bits//
			//Contiene tres campos de 1 bit//
			struct
			{
				unsigned int is_keyword : 1;
				unsigned int is_extern	: 1;
				unsigned int is_static	: 1;
			} flags;
			
			//Ejemplo de uso//
			flags.is_extern = flags.is_static = 1; //para encender los bits//
			flags.is_extern = flags.is_static = 0; //para apagar los bits//
			if (flags.is_extern == 0 && flags.is_static == 0) //para probarlos//

	NOTAS:
		· Casi todo en los campos es dependiente de la implementación.
		· No son arrays y no tienen direcciones, de modo que el operador & no se puede aplicar.
		· El ancho especial 0 puede usarse para obligar a la alineación al siguiente límite de palabra.


Capítulo 7. Entrada y salida
-----------------------------
7.1 Entrada y salida estándar
7.2 Salida con formato: printf
7.3 Listado de argumentos de longitud variable
7.4 Entrada con formato: scanf
7.5 Acceso a archivos
7.6 Manejo de errores stderr y exit
7.7 Entrada y salida de líneas
7.8 Otras funciones
	7.8.1 Operaciones sobre cadenas <string.h>
	7.8.2 Prueba y conversión de clases de caracteres <chtype.h>
	7.8.3 Funciones ungetc y ungetch
	7.8.4 Ejecución de órdenes system(char *s)
	7.8.5 Administración de almacenamiento: malloc, calloc y free
	7.8.6 Funciones matemáticas <math.h>
	7.8.7 Generación de números aleatorios rand()
	
7.1 Entrada y salida estándar
	En el sistema operativo, a nivel de programación en C, existen tres tipos de flujos de datos:
	1. Entrada estándar (stdin)
	2. Salida estándar (stdout)
	3. Salida estándar de errores (stderr)
	Dentro del intérprete de comandos (shell) de Linux y en la ejecución de programas en C, éstos hacen uso de esos flujos de datos.

Filtros para el redireccionamiento: <, > y | (pipes)
	1. Redirección de entrada estándar: <
		Un archivo de texto puede substituir al teclado como entrada estándar (stdin) con el uso del filtro < (redirección de la entrada).
		NOTA: la cadena de entrada no está incluida entre los argumentos de la línea de órdenes de argv.
		Ejemplo:
			PC:~/pruebas$ comando1 < datos.txt
			PC:~/pruebas$ programa1 < datos.txt
			
	2. Redirección de la salida estándar: >
		Un archivo también puede substituir a la pantalla del ordenador como salida estándar (stdout) mediante la redirección de salida >.
		Ejemplo:
			PC:~/pruebas$ echo "hola caracola" > saludos.txt
	
	NOTA: La entrada y salida estándar pueden combinarse, lo que es interesante para la automatización de tareas varias:
		Ejemplo:
			 FibonacciInOut.exe > FibonacciOutData.txt < FibonacciInData.txt
			//Al comando le entran los datos de 'FibonacciInData.txt' con < y se escriben en 'FibonacciOutData.txt'.
	
	3. Interconexión (pipeline) entre procesos
		Dos programas o procesos pueden interconectar sus salidas estándar con su entrada estándar.
		Ejemplo:
			PC:~/pruebas$ comando1 | comando2
			PC:~/pruebas$ programa1 | programa2
			Se interconectan la salida estándar del primer comando/programa con la entrada estándar del segundo programa/comando.

7.2 Salida con formato—printf
	El comando printf tiene la siguiente sintaxis:
		int printf(char *format, arg1, arg2, ...)
	Este comando convierte, da formato e imprime sus argumentos en la salida estándar bajo el control de format. 
	Regresa el número de caracteres impresos.
	La cadena de formato contiene dos tipos de objetos:
		· Caracteres ordinarios, que son copiados al flujo de salida.
		· Especificaciones de conversión, cada uno de los cuales causa la conversión e impresión de los siguientes argumentos sucesivos de printf.
			Cada especificación de conversión comienza con un carácter de tanto por ciento (%) y termina con un carácter de conversión (véase Tabla 7.2.2).
			Entre el símbolo % y el carácter de conversión puede haber otros símbolos (véase Tabla 7.2.1).

		Tabla 7.2.1 Símbolos entre % y carácter de conversión
				(orden en que deben aparecer)
------------------------------------------------------------------------
 - (signo menos)	|	Ajuste a la izquierda del argumento convertido
 (número)			|	Ancho mínimo de campo (relleno de blancos a la izquierda)
 . (punto)			|	Separa el ancho de campo de la precisión
 (número)			|	Ancho de campo del punto decimal
 h ó l				|	Si el entero será impreso como un short (h) o long (l)
 

		Tabla 7.2.2 Especificaciones de conversión de printf()
------------------------------------------------------------------------
 d, i	|	int; número decimal
 o		|	int; número octal sin signo (sin cero inicial)
 x, X	|	int; número hexadecimal sin signo (con prefijo 0x ó 0X, usando abcdef o ABCDEF
 u		|	int; número decimal sin signo
---------------------------------------------------------------------------------------------
 c		|	int; carácter sencillo
 s		|	char *; imprime caracteres de una cadena hasta un '\0' o el número de caracteres 
		|		dado por la precisión
---------------------------------------------------------------------------------------------		
 f		|	double; por defecto: [-]m.dddddd (m = mantisa, d = decimal)
 e, E	|	double; [-]m.dddddde±xx ó [-]m.ddddddE±xx
 g, G	|	double; si exponente menor a -4, usa %e ó %E, en otro caso
		|		usa %f
---------------------------------------------------------------------------------------------	
 p		|	void *; apuntador (representación dependiente de la 
		|		plataforma)
 %		|	No es convertido en ningún argumento, imprime un %
---------------------------------------------------------------------------------------------
 *		|	Amplitud o extensión, cuyo valor es el siguiente argumento de printf
		|		Ejemplo: printf("%.*s", max, s) // max es un int, imprime tantos caracteres como max//
---------------------------------------------------------------------------------------------
NOTA: cuidado, no es lo mismo
	printf(s);		//Falla si s contiene %//
	printf("%s", s)	//Seguro//
	El comando entregará resultados incorrectos si no hay suficientes argumentos o si tienen tipos incorrectos.
	
Función "sprintf"
 int sprintf(char *string, char *format, arg1, arg2...)
	Realiza las mismas funciones que printf, pero coloca el resultado en string en lugar de la salida estándar.

7.4 Entrada con formato: scanf
	Es la entrada análoga de printf, cuya sintaxis es:
		int scanf(char *format, ...)
	El comando hace tres cosas:
		1. Lee caracteres de la entrada estándar, 
		2. Los interpreta de acuerdo con las especificaciones de conversión que están en format,
		3. E indica dónde deben almacenarse la entrada correspondiente convertida, cuyos argumentos DEBEN SER PUNTEROS.
	Retorna el número de ítems de entrada que coinciden con éxito, lo que puede usarse para determinar cuántos ítems se encontraron.
	» Si un error de entrada ocurre antes de cualquier conversión, la función fscanf retorna el valor de la macro EOF.
	» Si retorna cero, es que hay un error de asignación con el siguiente carácter de entrada no coincide con la primera especificación en la cadena de formato.

Función "sscanf"
 int sscanf(char *cadena, char *format, arg1, arg2...)
	Equivalente a scanf, pero lee de cadena en lugar de la entrada estándar.

Cadena de formato puede contener
	· Blancos o tabuladores, los cuales son ignorados
	· Caracteres ordinarios (no %), que se espera coincidan con el siguiente carácter que no sea espacio en blanco del flujo de entrada.
	· Especificaciones de conversión, equivalente a printf

NOTA 1: Un campo de entrada se define como un string que no contiene espacios en blanco (tabulador, nueva línea, retorno de carro, tabulador vertical y avance de hoja).
NOTA 2: El carácter asterisco (*) indica que el campo de entrada siguiente debe ignorarse

Ejemplo. Se desea leer líneas de entrada que contienen fechas de la forma
		25 Dic 1988
	La proposición sscanf es
		int day, year;
		char monthname[20];
	
	scanf("%d %s %d", &day, monthname, &year);
	
	Si tiene la forma
		mm/dd/yyyy
	El programa quedaría
		int day, month, year;
		scanf("%d/%d/%d", &month, &day, &year);
	
	Si se desea que el programa lea en cualquiera de las dos formas anteriores:
	while (getline(line, sizeof(line)) > 0) {
		if (sscanf(line, "%d %s %d", &day, monthname, &year) == 3)
		{	printf("valid: %s\n", line); /* 25 Dec 1988 form */	}
		else if (sscanf(line, "%d/%d/%d", &month, &day, &year) == 3)
		{	printf("valid: %s\n", line); /* mm/dd/yy form */	}
		else
		{	printf("invalid: %s\n", line); /* invalid form */	}
	}
	
7.5 Acceso a archivos
	Dentro de la librería <stdio.h> se define la estructura FILE, puntero a ficheros, la cual sirve para acceder a archivos y que contiene información acerca del archivo como
		· ubicación de un buffer
		· la posición del carácter actual en el buffer
		· si el archivo está siendo leído o escrito
		· si han ocurrido errores o fin de archivo.
	Esta estructura se declara de la siguiente manera:
		FILE *fp; //Puntero a ficheros
		FILE *fopen(char *nombre, char *modo);
		
Apertura de ficheros: fopen
	Su sintaxis es la siguiente:
		FILE* fopen(const char nombrefichero[], const char modo[]);
	Argumentos de entrada:
		const char nombrefichero[]
			Nombre del fichero a abrir.
		const char modo[]
			Modo de apertura del fichero.
				r			Abre un fichero de texto para lectura
				w			Trunca, a longitud cero o crea un fichero de texto para escribir
				a			Añade; abre o crea un fichero de texto para escribir al final
								del fichero (EOF)
				rb 			Abre un fichero en modo binario para lectura
				wb			Trunca, a longitud cero o crea un fichero en modo binario 
								para escribir
				ab			Añade; abre o crea un fichero en modo binario para escribir 
								al final del fichero (EOF)
				r+ 			Abre un fichero de texto para actualización (lectura y escritura)
				w+ 			Trunca, a longitud cero o crea un fichero de texto para 
								actualización
				a+ 			Añade; abre o crea un fichero de texto para actualización, 
								escribiendo al final del fichero (EOF)
				r+b ó rb+ 	Abre un fichero en modo binario para actualización 
								(lectura y escritura)
				w+b ó wb+ 	Trunca, a longitud cero o crea un fichero en modo 
								binario para actualización
				a+b ó ab+ 	Añade; abre o crea un fichero en modo binario 
								para actualización, escribiendo al final del fichero (EOF)
 
	Parámetros de retorno
		FILE*	Puntero a un fichero.
					Si ocurre un error, retorna NULL.

Cierre de ficheros: fclose
	Su sintaxis es la siguiente:
		int fclose(FILE *f)
	Argumentos de entrada:
		FILE *f	Apuntador del fichero a cerrar.
	Parámetros de salida:
		Retorna cero si el stream fue cerrado con éxito. Si se detectaron errores, entonces retorna EOF.

Escritura y lectura de carácter:
	Lectura:	int fgetc(FILE *f)
	Escritura:	int fputc(int c, FILE *f) //tipo int, pero admite un char//
	
	Argumentos de salida:
		Si el stream está en el final de fichero, el indicador del final de fichero para el stream es activado y fgetc retorna EOF. 
		Si ocurre un error de lectura, el indicador de error para el stream es activado y fgetc retorna EOF.
		
	NOTA: getchar y putchar se definen a partir de fgetc y fputc con la entrada y salida estándar respectivamente.
		#define getchar()	getc(stdin)
		#define putchar(c)	putc(c, stdout)

Escritura y lectura de strings: fgets y fputs
	Lectura: 	char* fgets(char* s, int n, FILE *f) //Lee n-1 caracteres//
	Escritura:	char* fputs(const char* s, FILE *f)
	
	Argumento de salida:
		Retorna cadena si es realizada con éxito, EOF en otro caso.
		
Escritura y lectura de archivos con formato: fprintf y fscanf
	Lectura:	int fscanf(FILE *fp, char* formato, ...) //Variable deben ser PUNTEROS//
	Escritura:	int fprintf(FILE *fp, char* formato, ...)

Escritura y lectura general: fread y fwrite
	Lectura:	size_t fread(void *ptr, size_t size, size_t n_obj, FILE *f)
	Escritura:	size_t fwrite(const void *ptr, size_t size, size_t n_obj, FILE *f)
	//Lee o escribe n objetos de tamaño size a partir de la posición ptr//

	Ejemplos:	float d; fwrite( (void*)&d, sizeof(float), 1, f);
				int ai[10]; fwrite((void*)ai, sizeof(int), TAMARR, f);
				
Posición actual del puntero a fichero: ftell
	long ftell(FILE *f)
	
	int fseek(FILE *f, long offset, int origin)
		Macrospara origin:		SEEK_SET: principio
								SEEK_CUR: actual
								SEEK_END: final
	Actualiza la posición a offset posiciones de origen.

7.6 Manejo de errores stderr y exit
	Existe un flujo de datos de salida (stream) especialmente creado para el manejo de errores en los programas: stderr.
	Para utilizarlo, se usa 
		Sintaxis: int fprintf(stderr, char* formato, arg1, arg2, ...)

Función de <stdio.h> exit
	Termina la ejecución de un programa cuando se le llama.
	La llamada exit(0) señala que todo está bien, el resto de valores señalan situaciones anómalas.
	exit llama a fclose por cada archivo de salida abierto, para vaciar cualquier salida generada a través de un buffer.
	Dentro de main, return expr es equivalente a exit(expr)

Función de error en fichero ferror
	Sintaxis: int ferror(FILE *f_p)
	Devuelve un valor diferente a cero si ocurrió un error en el flujo f_p.

Función de fin de archivo feof
	Sintaxis: int feof(FILE *f_p)
	Devuelve un valor diferente a cero si ha ocurrido un fin de archivo en el archivo especificado.

7.8 Otras funciones de <stdio.h>
7.8.1 Operaciones sobre cadenas <string.h>

	char *strcat(s,t) 		concatenate t to end of s, returns s
	char *strncat(s,t,n)	concatenate n characters of t to end of s, returns s
	int strcmp(s,t) 		return negative, zero, or positive for s < t, s == t, s > t
	int strncmp(s,t,n) 		same as strcmp but only in first n characters
	char *strcpy(s,t)		copy t to s, returns s
	char *strncpy(s,t,n)	copy at most n characters of t to s, returns s
	size_t strlen(s) 		return length of s, '\0' not included
	char *strchr(s,c) 		return pointer to first c in s, or NULL if not present
	char *strrchr(s,c) 		return pointer to last c in s, or NULL if not present
	
7.8.2 Prueba y conversión de strings <ctype.h>

	int isalpha(c) non-zero if c is alphabetic, 0 if not
	int isupper(c) non-zero if c is upper case, 0 if not
	int islower(c) non-zero if c is lower case, 0 if not
	int isdigit(c) non-zero if c is digit, 0 if not
	int isalnum(c) non-zero if isalpha(c) or isdigit(c), 0 if not
	int isspace(c) non-zero if c is blank, tab, newline, return, formfeed, vertical tab
	int toupper(c) return c converted to upper case
	int tolower(c) return c converted to lower case
	
7.8.3 Funciones ungetc y ungetch
	int ungetc(char c, FILE *f)  retorna el carácter apilado después de la conversión. 
									Si la operación falla, entonces retorna EOF.

7.8.4 Ejecución de órdenes system(char *s)
	
	int system(const char *cadena) pasa al SO la cadena y devuelve lo mismo que el SO devuelve.

	Ejemplo: system("date") imprime fecha y hora del SO por stdout.
	
7.8.5 Administración de almacenamiento: malloc, calloc y free
	
	void malloc(size_t n) devuelve un puntero a n bytes de almacenamiento, NULL en otro case.
	
	void *calloc(size_t n, size_t size)  retorna o bien NULL o bien un puntero al espacio adjudicado.
	
	Casting: es necesario hacer un casting
		int ip = (int*) calloc(n, sizeof(int));
	
	Liberación de memoria: free(p)
	Ejemplo:
		for (p = head; p != NULL; p = p->next) /* WRONG */
			free(p); //You are not saving p->next//
		
		for (p = head; p != NULL; p = q) 
		{
			q = p->next;
			free(p);
		}

7.8.6 Funciones matemáticas <math.h>
	
	sin(x) sine of x, x in radians
	cos(x) cosine of x, x in radians
	atan2(y,x) arctangent of y/x, in radians
	exp(x) exponential function ex
	log(x) natural (base e) logarithm of x (x>0)
	log10(x) common (base 10) logarithm of x (x>0)
	pow(x,y) xy
	sqrt(x) square root of x (x>0)
	fabs(x) absolute value of x
	
7.8.7 Generación de números aleatorios rand()

	int rand() devuelve un entero pseudo-aleatorio entre 0 y RAND_MAX (definido en <stdlib.h>)
	
	#define frand() ((double) rand() / (RAND_MAX + 1))
	
Semilla de rand()
	void srand(unsigned int semilla)

Capítulo 8. La interfaz con el sistema UNIX (syscalls.h)
-------------------------------------------------------
8.1 Descriptores de archivos
8.2 Entrada y salida de bajo nivel: read y write
8.3 Open, creat, close, unlink
8.4 Acceso aleatorio: lseek
8.5 Ejemplo: una relación de fopen y getc
8.6 Ejemplo: listado de directorios
8.7 Ejemplo: asignador de memoria

8.1 Descriptores de ficheros.
	UNIX maneja todos los dispositivos periféricos, tales como teclado o pantalla, como ficheros en el sistema. Esto proporciona un interfaz común entre los manejadores de dispositivos y los programas.
	Cuando un programa intenta acceder a un archivo, en lectura o escritura, el sistema chequea la existencia del archivo y los derechos del proceso; si todo es correcto, devuelve devuelve al programa un entero llamado descriptor de fichero.
	
	Cuando el intérprete de comandos (el "shell") ejecuta un programa, tres ficheros se abren, con descriptores de ficheros 0, 1 y 2, llamados entrada estándar (stdin) (0), salida estándar (stdout) (1) y error estándar (stderr) (2).
	Si un programa lee en 0 y escribe en 1 y 2, puede usar la entrada y la salida sin preocuparse sobre abrir ficheros.
	
	Un usuario puede redirigir la entrada y la salida entre ficheros usando los operadores de redireccionamiento < y >:
	Ejemplo:	programa.exe < fichero_entrada > fichero_salida
		Con este programa, el shell reasigna el descriptor 0 por el del fichero de entrada y el descriptor 1 por el fichero de salida.
		
8.2 Entrada y salida de bajo nivel—read y write
	La entrada y la salida usa las system calls de lectura y escritura, las cuales son accedidas desde programas C a través de las dos funciones llamadas read y write.

	int n_read = read(int fd, char *buf, int n);
	int n_written = write(int fd, char *buf, int n);
		int fd		Descriptor de fichero
		char *buf	String donde los datos van o vienen
		int n		Número de bytes a transmitir
		int n_read	Devuelve el número de bytes transmitidos.
					En lectura, el número de bytes devueltos puede ser menor que el requerido.
						Si devuelve 0, se ha llegado al final del fichero.
						Si devuelve -1, ha ocurrido algún error.
					En escritura, el número de bytes devueltos debe ser igual al número de bytes escritos. Si no es así, habrá ocurrido un error.
	
	Cualquier número de bytes puede ser leído o escrito en una llamada. El valor más común es 1, lo que significa un carácter cada vez ("unbuffered"), y un número como 1024 o 4096 corresponde a un tamaño físico en un dispositivo periférico. Mayores tamaños de acceso serán más eficientes porque menos systems calls se realizarán.

	Ejemplo: Copiar la entrada estándar a la salida estándar.
		#include "syscalls.h"
		main() /* copy input to output */
		{
			char buf[BUFSIZ];
			int n;
			while ((n = read(0, buf, BUFSIZ)) > 0)
			write(1, buf, n);
			return 0;
		}

	El parámetro BUFSIZ se define también en syscalls.h, su valor es un buen tamaño para el sistema local. Si el tamaño de archivo no es un múltiplo de BUFSIZ, alguna lectura devolverá un menor número de bytes para ser escritos y la siguiente llamada después de ésta devolverá cero.

	Ejemplo 2: Función getchar programada a partir de syscall.h
		#include "syscalls.h"
		/* getchar: unbuffered single character input */
		int getchar(void)
		{
			char c;
			return (read(0, &c, 1) == 1) ? (unsigned char) c : EOF;
		}

	Una versión más refinada con lectura en bloques:
		#include "syscalls.h"
		/* getchar: simple buffered version */
		int getchar(void)
		{
			static char buf[BUFSIZ];
			static char *bufp = buf;
			static int n = 0;
			if (n == 0) 
			{ /* buffer is empty */
			n = read(0, buf, sizeof buf);
			bufp = buf;
			}
			return (--n >= 0) ? (unsigned char) *bufp++ : EOF;
		}
 
8.3 Open, creat, close, unlink
	Además de las entradas y salidas estándar, hay que abrir ficheros explícitamente para leerlos y escribirlos. Para ello hay dos system calls, open y creat (sic).
	
	int open(char *name, int flags, int perms);
		char *name	String que contiene el nombre de fichero.
		int flags	Especifica cómo el fichero debe ser abierto.
					O_RDONLY open for reading only
					O_WRONLY open for writing only
					O_RDWR open for both reading and writing
		int perms	Especifica los permisos de acceso.
		int			Devuelve un descriptor de archivo
					Si hay algún error, devuelve -1.
		Ejemplo:
			fd = open(name, O_RDONLY,0);
	
	int creat(char *name, int perms);
		int			Devuelve un descriptor si pudo crear el fichero, -1 eoc.
					Si el archivo ya existía, lo truncará a longitud cero, descartando el contenido anterior. No es un error hacer un creat de un archivo existente.
		int perms	Determina los permisos de creación de un archivo.

	En el sistema de fichero de UNIX, hay nueve bits asociados a la información de permiso con un fichero que controla el acceso a lectura, escritura y ejecución para el propietario del archivo, el grupo y el resto. Así, un número octal de tres dígitos es conveniente para especificar los 141 permisos.
	Por ejemplo, 0775 especifica la lectura, escritura y ejecución de permisos para el propietario, y lectura y ejecución para el grupo y el resto de personas.

	Ejemplo: 
		/**
			\title Una versión simplificada de cp de UNIX.
			\description Copia sólo un fichero, no permite al segundo argumento ser un directorio e inventa permisos en lugar de copiarlos.
		*/
		#include <stdio.h>
		#include <fcntl.h>
		#include "syscalls.h"
		#define PERMS 0666 /* RW for owner, group, others */
		
		void error(char *, ...);
		
		/* cp: copy f1 to f2 */
		main(int argc, char *argv[])
		{
			int f1, f2, n;
			char buf[BUFSIZ];
			if (argc != 3)
			{	error("Usage: cp from to");	}
			if ((f1 = open(argv[1], O_RDONLY, 0)) == -1)
			{	error("cp: can't open %s", argv[1]); }
			if ((f2 = creat(argv[2], PERMS)) == -1)
			{	error("cp: can't create %s, mode %03o", argv[2], PERMS);	}
			while ((n = read(f1, buf, BUFSIZ)) > 0)
			{
				if (write(f2, buf, n) != n)
				{	error("cp: write error on file %s", argv[2]);	}
			}
			return 0;
		}
		
		#include <stdio.h>
		#include <stdarg.h>
		/* error: print an error message and die */
		void error(char *fmt, ...)
		{
			va_list args;
			va_start(args, fmt);
			fprintf(stderr, "error: ");
			vprintf(stderr, fmt, args);
			fprintf(stderr, "\n");
			va_end(args);
			exit(1);
		}
		
	close (int fd)	rompe la conexión entre un descriptor de fichero y un archivo abierto, y libera el descriptor de fichero para usarlo con cualquier otro archivo.
	exit ó return 	Cierra todos los ficheros.
	
	unlink(char *name)	borra el fichero name del sistema de ficheros.
	
8.4 Acceso aleatorio—lseek
	La system call lseek proporciona una forma de moverse a lo largo del archivo sin leer o escribir datos.
	long lseek(int fd, long offset, int origin);
		int fd		Descriptor de fichero a recorrer.
		long offset	Posición relativa a recorrer.
		int origin	Posición absoluta desde la que offset se desplaza.
					0 Offset medido desde el principio
					1 Offset medido desde posición actual
					2 Offset medido desde el final del archivo
		long		Devuelve un long con la nueva posición en el fichero.
					Si ocurre algún error, devuelve -1.

	Ejemplo: para apendar un archivo se usaría
		lseek(fd, 0L, 2)
	y para volver atrás al principio
		lseek(fd, 0L, 0) //0L = (long)0//
	
	
	#include "syscalls.h"
	/*get: read n bytes from position pos */
	int get(int fd, long pos, char *buf, int n)
	{
		if (lseek(fd, pos, 0) >= 0) /* get to pos */
		return read(fd, buf, n);
		else
		return -1;
	}
	
8.5 Ejemplo: una relación de fopen y getc

	#define NULL 0
	#define EOF (-1)
	#define BUFSIZ 1024
	#define OPEN_MAX 20 /* max #files open at once */
	
	typedef struct _iobuf 
	{
		int cnt; /* characters left */
		char *ptr; /* next character position */
		char *base; /* location of buffer */
		int flag; /* mode of file access */
		int fd; /* file descriptor */
	} FILE;
	extern FILE _iob[OPEN_MAX];
	
	#define stdin (&_iob[0])
	#define stdout (&_iob[1])
	#define stderr (&_iob[2])
	
	enum _flags 
	{
		_READ = 01, /* file open for reading */
		_WRITE = 02, /* file open for writing */
		_UNBUF = 04, /* file is unbuffered */
		_EOF = 010, /* EOF has occurred on this file */
		_ERR = 020 /* error occurred on this file */
	};
	
	int _fillbuf(FILE *);
	int _flushbuf(int, FILE *);
	
	#define feof(p) ((p)->flag & _EOF) != 0)
	#define ferror(p) ((p)->flag & _ERR) != 0)
	#define fileno(p) ((p)->fd)
	
	#define getc(p) (--(p)->cnt >= 0 \
					? (unsigned char) *(p)->ptr++ : _fillbuf(p))
	#define putc(x,p) (--(p)->cnt >= 0 \
					? *(p)->ptr++ = (x) : _flushbuf((x),p))

	#define getchar() getc(stdin)
	#define putcher(x) putc((x), stdout)
	
	/** fopen*/
	#include <fcntl.h>
	#include "syscalls.h"
	#define PERMS 0666 /* RW for owner, group, others */

	FILE *fopen(char *name, char *mode)
	{
		int fd;
		FILE *fp;

		if (*mode != 'r' && *mode != 'w' && *mode != 'a')
			return NULL;
		for (fp = _iob; fp < _iob + OPEN_MAX; fp++)
			if ((fp->flag & (_READ | _WRITE)) == 0)
				break; /* found free slot */
		if (fp >= _iob + OPEN_MAX) /* no free slots */
			return NULL;
		if (*mode == 'w')
			fd = creat(name, PERMS);
		else if (*mode == 'a')
		{
			if ((fd = open(name, O_WRONLY, 0)) == -1)
				fd = creat(name, PERMS);
			lseek(fd, 0L, 2);
		}
		else fd = open(name, O_RDONLY, 0);
		if (fd == -1) /* couldn't access name */
			return NULL;
		fp->fd = fd;
		fp->cnt = 0;
		fp->base = NULL;
		fp->flag = (*mode == 'r') ? _READ : _WRITE;
		return fp;
	}
	
	#include "syscalls.h"
	/* _fillbuf: allocate and fill input buffer */
	int _fillbuf(FILE *fp)
	{
		int bufsize;
		if ((fp->flag&(_READ|_EOF_ERR)) != _READ)
		return EOF;
		bufsize = (fp->flag & _UNBUF) ? 1 : BUFSIZ;
		if (fp->base == NULL) /* no buffer yet */
		if ((fp->base = (char *) malloc(bufsize)) == NULL)
		return EOF; /* can't get buffer */
		fp->ptr = fp->base;
		fp->cnt = read(fp->fd, fp->ptr, bufsize);
		if (--fp->cnt < 0) {
		if (fp->cnt == -1)
		fp->flag |= _EOF;
		else
		fp->flag |= _ERR;
		fp->cnt = 0;
		return EOF;
	}
	return (unsigned char) *fp->ptr++;
	
	FILE _iob[OPEN_MAX] = 
	{ /* stdin, stdout, stderr */
		{ 0, (char *) 0, (char *) 0, _READ, 0 },
		{ 0, (char *) 0, (char *) 0, _WRITE, 1 },
		{ 0, (char *) 0, (char *) 0, _WRITE, | _UNBUF, 2 
	}
	
Webs sobre C
www.zator.com
www.elrincondelc.com
www.cconclase.net
http://eclipsebook.in/
http://www.eclipse.org/resources/?sort=date&category=CDT
http://adobedev.adobe.acrobat.com/p20583465/?launcher=false&fcsContent=true&pbMode=normal
http://www.programacionenc.net
http://www.yolinux.com